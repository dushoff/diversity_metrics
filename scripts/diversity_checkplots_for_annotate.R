# script to make checkplots for Chao's variance estimators for diversity estimates. Also creates non-checkplot figure of CI coverage for Chao1 for the conceptual guide.

#############
#load functions and packages
library(furrr)#parallelization
source("scripts/helper_funs/uniroot_gamma_and_lnorm.R")
# source("scripts/helper_funs/prettify.R")
# library(scales)#trans_breaks
# # library(mobsim)#simulate communities
# library(cowplot) #sometimes nice stuff for multipanel ggplotting
# invlogit<-arm::invlogit
#library(vegan) # for fisherfit
#library(MASS) # for fitdistr
# library(scales) #for function muted
select<-dplyr::select

########################################
#simulate communities 
# #start with JD comms
# mini<-100
# com1 <- c(1, 1, 1, 1)
# com2 <- c(1, rep(1/(mini-1), mini))
# #add a more naturalistic one
# com3<-as.numeric(sim_sad(s_pool=60, n_sim=100000))
# #this is supersampling
# o1<-sample(1:length(com1), prob=com1, size=inds, replace=T)
# o2<-sample(1:length(com2), prob=com2, size=inds, replace=T)



# #make a community for User's Guide
# usersguide<-as.numeric(sim_sad(s_pool=120, n_sim=1000000, sad_coef=list(cv_abund=5)))
# 
# 
# #three communities with richness ~60, and different skew
# com1<-as.numeric(sim_sad(s_pool=60, n_sim=100000, sad_coef=list(cv_abund=2)))
# com2<-as.numeric(sim_sad(s_pool=60, n_sim=100000, sad_coef=list(cv_abund=5)))
# com3<-as.numeric(sim_sad(s_pool=60, n_sim=100000, sad_coef=list(cv_abund=10)))

# simulate communities with fit_SAD, basically isntantaneous

SADs_list<-map(c("lnorm", "gamma"), function(distr){
  map(c(100, 200), function(rich){
    map(c(.15,.25,.5,.75,.85), function(simp_Prop){
      fit_SAD(rich = rich, simpson = simp_Prop*rich, dstr = distr)
    })
  })
})




# #quick summary to see how distributional assumption affects Shannon
# see_Shannon <- map_dfr(SADs_list, function(dst){
#   map_dfr(dst, function(R){
#     map_dfr(R, function(S){
#       return("summaryStats" =data.frame(t(c(S$distribution_info, S$community_info))))
#     })
#   })
# })
# 
# #well, not much! But shannon is always higher with lnorm
# pdf("figures/Shannon_higher_with_lnorm.pdf")
# see_Shannon %>% 
#   ggplot(aes(as.numeric(as.character(Hill.Simpson))/as.numeric(as.character(richness))
#              , as.numeric(as.character(Hill.Shannon)), color=distribution, shape=richness))+
#     geom_point()+theme_classic()+scale_y_log10() +
#     scale_x_log10()+
#     labs(x="Hill-Simpson as fraction of richness", y="Hill-Shannon")
# dev.off()
# pdf(height=2, width=6, file="figures/simssads.pdf")
# par(mfrow=c(1,3))
# plot(1:length(com1), com1, xlab="",  ylab="species abundance", type="line", ylim=c(0,26000))
# plot(1:length(com2), com2, xlab="species rank", ylab="", type="line", ylim=c(0,26000))
# plot(1:length(com3), com3, xlab="", ylab="", type="line", ylim=c(0,26000) )
# dev.off()

asab<-function(namevec){as.numeric(table(namevec))}



#gets slightly closer than obs
# show1<-checkplot(com1, l=0, inds=150, reps=1000)

####################################
#set up parallelization for large computations

#set # cores
nc<-20#per Rob's recommendation


plan(strategy=multiprocess, workers=nc) #this is telling the computer to get ready for the future_ commands

########################
# function to generate data for checkplots for fixed communities
# checkplot<-function(abs, B=Bnum, l, inds, reps){
#   td<-dfun(abs, l) #compute true diversity
#   #truemu_n<-mean(replicate(B,dfun(subsam(abs, inds),l)))
#   future_map_dfr(1:reps,function(x){
#     obs<-subsam(abs, size=inds) #subsample true community within each replicate
#     chaotile<-checkchao(obs, B, l, td) #then do B bootstrap samples for the augmented community based on that sample
#     return(chaotile=data.frame(qtile=chaotile[1], truediv=chaotile[2], chaoest=chaotile[3], obsD=chaotile[4], l=l, inds=inds, reps=reps))
# 
#   })
# }

# for infinite community, generated by fit_SAD (SAD is the name of that list object)
checkplot_inf<-function(SAD, B=2000, l, inds, reps){
  hillname<-ifelse(l==-1, "Hill-Simpson", ifelse(l==0, "Hill-Shannon", "richness"))
  td<-SAD$community_info[hillname] #grab true diversity from SAD object
  #truemu_n<-mean(replicate(B,dfun(subsam(abs, inds),l)))
  future_map_dfr(1:reps,function(x){
    # obs<-subsam(abs, size=inds) #subsample true community within each replicate
    
    obs <- sample_infinite(SAD$rel_abundances,size=inds) #subsample the whole community with # individuals=size
    chaotile<-checkchao(obs, B, l, td) #then do B bootstrap samples for the augmented community based on that sample
    return(chaotile=data.frame(qtile=chaotile[1], truediv=chaotile[2], chaoest=chaotile[3], obsD=chaotile[4], l=l, inds=inds, reps=reps))
    
  })
}



#########################
#This uses two functions to generate the CI and the true average sample diversity for different sample sizes for a single community

#Generates quantiles of bootstrap distribution given true diveristy, sample size, l, and true average 
#for infinite community. Note that SAD is a list generated by fit_SAD
obscp_inf <- function(l=l, size=size, SAD=SAD, B=2000, truemun=truemun...){
  sam <- sample_infinite(SAD$rel_abundances, size=size)
  data.bt = rmultinom(B,size,Bt_prob_abu(sam)) #this genenerates "bootstrapped" samples, using Chao's fancy method
  obs<-dfun(sam,l) #K. here we are just taking a single sample and computing the observed diversity
  pro = apply(data.bt,2,function(boot)dfun(boot, l)) #This had been inconsistent with intent and was doing estimator stuff where we just wanted the naive answer.
  pro_mc<-pro-mean(pro)+obs
  chaotile_mc<-sum(pro_mc<=truemun)/(B/100)
  chaotile<-sum(pro<=truemun)/(B/100)
  return(data.frame("chaotile"=chaotile, "chaotile_mc"=chaotile_mc,
                    "truemu"=truemun,  "obsD"=obs, "l"=l, "size"=size ))
}

#for a fixed community 
# obscp<-function(l=l, size=size, dat=usersguide, B=2000, truemun=truemun...){
#   sam<-subsam(dat, size) #substample the whole community with # individuals=size
#   data.bt = rmultinom(B,size,Bt_prob_abu(sam)) #this genenerates "bootstrapped" samples, using Chao's fancy method
#   obs<-dfun(sam,l) #K. here we are just taking a single sample and computing the observed diversity
#   pro = apply(data.bt,2,function(boot)dfun(boot, l)) #This had been inconsistent with intent and was doing estimator stuff where we just wanted the naive answer.
#   pro_mc<-pro-mean(pro)+obs
#   chaotile_mc<-sum(pro_mc<=truemun)/(B/100)
#   chaotile<-sum(pro<=truemun)/(B/100)
#   return(data.frame("chaotile"=chaotile, "chaotile_mc"=chaotile_mc, "truemu"=truemun,  "obsD"=obs, "l"=l, "size"=size ))
# }

#set number of reps
reps<-5000
Bnum<-200

####################
#run this whole thing to get sample diversity checkplot-type info for sample diversity for a single community
trycheckingobs<-function(SAD){
  map_dfr(round(10^seq(2, 5.5, 0.25)), function(size){
    map_dfr(c(-1,0,1), function(ell){
          truemun<-truemu_inf(SAD$rel_abundances, size=size, reps=reps, l=ell)
            map_dfr(1:reps, function(reps){obscp_inf(l=ell, size, SAD, truemun=truemun, B=Bnum)
            })
      })
  })
}
##### apparently this was streamlined enough to store to a single .csv while running in parallel


future_map(1:length(flatten(flatten(SADs_list))), function(SAD){
  write.csv(trycheckingobs(flatten(flatten(SADs_list))[[SAD]])
            , file=paste("data/fromR/trycheckingobs_SAD_", SAD, ".csv", sep=""), row.names=F)
  })

# write.csv(trycheckingobs_R, file="data/big_richness_checkplot.csv", row.names=F)

# write.csv(trycheckingobs, file="data/fromR/trycheckingobs_with_without_mc.csv", row.names=F)


##################################
# read in data and make checkplot for sample diveristy
# trycheckingobs<-read.csv("data/fromR/trycheckingobs_with_without_mc.csv")

#####################
#checkplot figure, not used in users guide, now does checkplot without mean correction. 
# pdf(file="figures/empirical_checkplot1_nomc.pdf")
# map(c(-1,0,1), function(ell){
#     trycheckingobs %>% filter(l==ell) %>% 
#         ggplot(aes(chaotile))+
#         geom_histogram()+
#         theme_classic()+
#         facet_wrap(~size+l)
# })
# dev.off()
# 
# pdf(file="figures/do_richness_CI_ever_work.pdf")
# trycheckingobs_R %>% 
#   ggplot(aes(chaotile))+
#   geom_histogram()+
#   theme_classic()+
#   labs(x="percentile of mean sample richness in 500k bootstrap samples", y="frequency")+
#   facet_wrap(~size)
# dev.off()

####################################
# # set up data for users guide figures
# nreps<-5000 #this should be 5000 for now
# 
# #df with true coverage of 95% CI
# tvcov <-trycheckingobs %>% group_by(l, size) %>% summarize(outside=1-(sum(chaotile_mc>97.5)+sum(chaotile_mc<2.5))/(nreps*100))
# 
# #relable facets by creating new factor in df
# inds<-data.frame("l"=c(1,0,-1), divind=factor(c("richness", "Hill-Shannon", "Hill-Simpson"), levels=c("richness", "Hill-Shannon", "Hill-Simpson")))
# 
# tc<-left_join(tvcov, inds)
# 




###############################################
# confirm enough reps to get observed mean and true mean to be the same here
# checktruemu<-trycheckingobs %>% group_by(l, size) %>% summarize(tm=mean(truemu), om=mean(obsD))
# checktruemu %>% ggplot(aes(tm, om))+geom_point()
#################################################
# this is asymptotic diversity for users guide

#set reps to 500 but outerreps to 10 for efficient use of anotate
reps<-500
outerreps<-10
nc<-36#per Rob's recommendation


plan(strategy=multiprocess, workers=nc) 
#####################
#uncomment to generate data for asymptotic diveristy checkplot/coverage for conceptual guide

map(1:length(flatten(flatten(SADs_list))), function(SAD){
  map(1:outerreps, function(x){
    ug_asy<-map_dfr(round(10^seq(2, 5.5, 0.25)), function(size){
        map_dfr(c(-1,0,1), function(l){
            out<-checkplot_inf(flatten(flatten(SADs_list))[[SAD]], l=l, inds=size, reps=reps)
        })
    })
    write.csv(ug_asy, paste("data/SAD", SAD, "asy",  x, ".csv", sep="_"), row.names=F)
    # return(ug_asy)
  })
})


