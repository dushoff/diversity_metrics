# script to make checkplots for Chao's variance estimators for diversity estimates. Also creates non-checkplot figure of CI coverage for Chao1 for the conceptual guide.

#############
#load functions and packages
library(furrr)#parallelization
source("scripts/helper_funs/uniroot_gamma_and_lnorm.R")
# source("/Rstudio_Git/Dushoff_diversity/scripts/helper_funs/radplot.R")
# source("scripts/helper_funs/prettify.R")
library(scales)#trans_breaks
# library(cowplot) #sometimes nice stuff for multipanel ggplotting
# invlogit<-arm::invlogit
#library(vegan) # for fisherfit
#library(MASS) # for fitdistr
# library(scales) #for function muted
select<-dplyr::select

# function to remove subscripts
remsub <- function(variable, value){
  return(gsub("_"," ",value))}

#function to summarize frequencies
asab<-function(namevec){as.numeric(table(namevec))}

###################
# function to compute CV
mycv<-function(x){sd(x)/mean(x)}



########################################
# simulate communities with fit_SAD, basically isntantaneous

SADs_list<-map(c("lnorm", "gamma"), function(distr){
  map(c(100, 200), function(rich){
    map(c(0.05, .15,.25,.5,.75,.85), function(simp_Prop){
      fit_SAD(rich = rich, simpson = simp_Prop*(rich-1)+1, dstr = distr)
    })
  })
})




# #will do forked in base R and sometimes in Rstudio at least on my mac
# plan(strategy=multiprocess, workers=nc) 
# 
# reps<-200
# ###################
# #this looks like it is checking someething abotu Simpson but it looks kind of wrong
# checkvars<-future_map_dfr(3:300*10, function(ss){
#   map_dfr(1:reps, function(rep){
#     mys<-sample_infinite(SADs_list[[1]][[2]][[1]][[3]], ss)
#     data.frame(asy_Simpson=Chao_Hill_abu(mys, q=1), sampsimp=dfun(mys, 0), ss=ss)
#   })
#   
# })
# 


############
# # did checkvars used to be something else? 
# checkvars %>% group_by(m) %>%  mutate_at(c("SC", "q = 0","q = 1","q = 2" ), mycv) %>% 
#   ggplot(aes(m, SC))+geom_point()+geom_point(aes(y=`q = 0`), color="red")+
#   geom_point(aes(y=`q = 1`), color="blue")+
#   geom_point(aes(y=`q = 2`), color="green")+theme_classic()
# 
# mydf %>% ggplot(aes(x,y))+geom_smooth()
# #quick summary to see how distributional assumption affects Shannon
# see_Shannon <- map_dfr(SADs_list, function(dst){
#   map_dfr(dst, function(R){
#     map_dfr(R, function(S){
#       return("summaryStats" =data.frame(t(c(S$distribution_info, S$community_info))))
#     })
#   })
# })

#well, not much! But shannon is always higher with lnorm
# pdf("figures/Shannon_higher_with_lnorm.pdf")
# see_Shannon %>% 
#   ggplot(aes(as.numeric(as.character(Hill.Simpson))/as.numeric(as.character(richness))
#              , as.numeric(as.character(Hill.Shannon)), color=distribution, shape=richness))+
#     geom_point()+theme_classic()+scale_y_log10() +
#     scale_x_log10()+
#     labs(x="Hill-Simpson as fraction of richness", y="Hill-Shannon")
# dev.off()

##############
# make rank abundance distributions
# myabs<-map_dfr(flatten(flatten(SADs_list)) #, function(x) data.frame(names(x)))
#                , function(x){data.frame(ab=x$rel_abundances)}
#                , .id="SAD")
# 
# 
# pdf("figures/RAD_for_extreme_SADs_rich_200.pdf")
# myabs %>% left_join(data.frame(
#   SAD=as.character(1:24)
#   , skew=factor(c("uneven", "int","int", "int","int", "even"), levels=c("uneven", "int", "even"))
#   , dist=factor(c(rep("lognormal", 12), rep("gamma", 12)), levels=c("lognormal", "gamma"))
# )) %>% 
#   mutate(abD=paste(dist, skew)) %>% 
#   group_by(SAD, abD, dist, skew) %>% 
#   mutate(abrank=min_rank(desc(ab)), log_relative_abundance=log(ab), relative_abundance=ab) %>% 
#   gather(scl, rel_abund, relative_abundance, log_relative_abundance )%>% 
#   filter(SAD %in% c("7","10","12","19","22","24")) %>% 
#   ggplot(aes(abrank, rel_abund, color=dist))+
#     geom_point(alpha=0.1, size=1)+
#     geom_line(size=.4, alpha=0.1)+
#     theme_classic()+
#     theme(text=element_text(size=16))+
#     labs(x="abundance rank", y="", color="", shape="")+
#     facet_grid(fct_rev(scl)~skew, scales="free", switch="y", labeller=remsub)
# dev.off()               
# 


####################################
#set up parallelization for large computations

#set # cores
# nc<-43#per Rob's recommendation
# 
# 
# plan(strategy=multiprocess, workers=nc) #this is telling the computer to get ready for the future_ commands

########################
# # function to generate data for checkplots for fixed communities
# checkplot<-function(abs, B=Bnum, l, inds, reps){
#   td<-dfun(abs, l) #compute true diversity
#   #truemu_n<-mean(replicate(B,dfun(subsam(abs, inds),l)))
#   future_map_dfr(1:reps,function(x){
#     obs<-subsam(abs, size=inds) #subsample true community within each replicate
#     chaotile<-checkchao(obs, B, l, td) #then do B bootstrap samples for the augmented community based on that sample
#     return(chaotile=data.frame(qtile=chaotile[1], truediv=chaotile[2], chaoest=chaotile[3], obsD=chaotile[4], l=l, inds=inds, reps=reps))
# 
#   })
# }

# for infinite community, generated by fit_SAD (SAD is the name of that list object)
checkplot_inf<-function(SAD, B=2000, l, inds, reps){
  hillname<-ifelse(l==-1, "Hill-Simpson", ifelse(l==0, "Hill-Shannon", "richness"))
  td<-SAD$community_info[hillname] #grab true diversity from SAD object
  #truemu_n<-mean(replicate(B,dfun(subsam(abs, inds),l)))
  future_map_dfr(1:reps,function(x){
    # obs<-subsam(abs, size=inds) #subsample true community within each replicate
    
    obs <- sample_infinite(SAD$rel_abundances, size=inds) #subsample the whole community with # individuals=size
    
    chaotile <- checkchao(x=obs, B=B, l=l, truediv=td) #then do B bootstrap samples for the augmented community based on that sample
    return(myout=data.frame(p=chaotile$p
                            , truediv=chaotile$truediv
                            , chaoest=chaotile$chaoest
                            , obsD=chaotile$obsD
                            , upper=chaotile$upper
                            , lower=chaotile$lower
                            , l
                            , inds
                            , reps)
    )
    
  })
}
#################################################
#asymptotic diversity checkplots
# 
# # #set reps to 5000 but outerreps to 10 for efficient use of anotate
# reps<-5000
# outerreps<-10
# nc<-15#per Rob's recommendation
# plan(strategy=multiprocess, workers=nc)
# 
# map(c(7,19,10,22,12,24), function(SAD){
#   map(1:outerreps, function(x){
#    map(rev(round(10^seq(2, 5, 0.25))), function(size){
#       map(c(-1,1), function(l){
#         start<-Sys.time()
#         
#         out<-checkplot_inf(flatten(flatten(SADs_list))[[SAD]], l=l, inds=size, reps=reps)
#         write.csv(out, paste("data/SAD", SAD, "l", l, "inds", size, "outer",  x, ".csv", sep="_"), row.names=F)# out<-checkplot_inf(flatten(flatten(SADs_list))[[7]], l=l, inds=size, reps=reps)
#         print(Sys.time()-start)
#       })
#     })
#     
#     # write.csv(ug_asy, paste("data/SAD_7_asy",  x, ".csv", sep="_"), row.names=F)
#     # return(ug_asy)
#   })
# })


map(c(rev(1:24)), function(SAD){
  map(c(-1,0,1), function(l){
    p<-SAD*3-2+l

mycode<-c(
  "source(\"scripts/checkplot_initials.R\")"
,  "source(\"scripts/checkplot_inf.R\")"
,  "reps<-50"
, "outerreps<-1000"
, "nc<-12"
, "plan(strategy=multisession, workers=nc)"

, "map(rev(1:outerreps), function(x){"
, "    map(rev(round(10^seq(2, 5, 0.25))), function(size){"
, "        start<-Sys.time()"
        
, paste0("out<-checkplot_inf(flatten(flatten(SADs_list))[[", SAD, "]], l=", l, ", inds=size, reps=reps)")
,         paste0("write.csv(out, paste(\"data/SAD", SAD, "\",\"l\",", l, ",\"inds\", size, \"outernew\",  x, \".csv\", sep=\"_\"), row.names=F)")
, "rm(out)"
,       "print(Sys.time()-start)"
,      "})"

, "})")

write_lines(mycode, paste0("scripts/asy_",p, ".R"))

  })
})
  





#########################
#This uses two functions to generate the CI and the true average sample diversity for different sample sizes for a single community

#Generates quantiles of bootstrap distribution given true diveristy, sample size, l, and true average 
#for infinite community. Note that SAD is a list generated by fit_SAD
obscp_inf <- function(l=l, size=size, SAD=SAD, B=2000, truemun=truemun, conf=0.95,...){
  sam <- sample_infinite(SAD$rel_abundances, size=size)
  data.bt = rmultinom(B,size,Bt_prob_abu(sam)) #this genenerates "bootstrapped" samples, using Chao's fancy method
  obs<-dfun(sam,l) #observed diversity
  pro = apply(data.bt,2,function(boot)dfun(boot, l)) #sample diversity for bootstraps
  pro_mc<-pro-mean(pro)+obs

  less<-sum(pro_mc<truemun)/length(pro_mc)
  more<-(length(pro_mc)-sum(pro_mc>truemun))/length(pro_mc)
  p<-runif(1, min(less, more), max(less, more))
  
  lower<-max(pro_mc[which(min_rank(pro_mc)<=max(floor(B*(1-conf)/2),1))])
  upper<-min(pro_mc[which(min_rank(-pro_mc)<=max(floor(B*(1-conf)/2),1))])
  
  less_no_mc<-sum(pro<truemun)/length(pro)
  more_no_mc<-(length(pro)-sum(pro>truemun))/length(pro)
  p_no_mc<-runif(1, min(less, more), max(less, more))
  
  lower_no_mc<-max(pro[which(min_rank(pro)<=max(floor(B*(1-conf)/2),1))])
  upper_no_mc<-min(pro[which(min_rank(-pro)<=max(floor(B*(1-conf)/2),1))])
  
  
  # chaotile_mc<-findInterval(truemun, quantile(pro_mc, seq(0,1,0.0005)), all.inside = T)/20
  # chaotile<-findInterval(truemun, quantile(pro, seq(0,1,0.0005)), all.inside=T)/20

  return(data.frame("p"=p, "p_no_mc"=p_no_mc
                    , upper = upper
                    , lower = lower
                    , upper_no_mc = upper_no_mc
                    , lower_no_mc = lower_no_mc
                    , "truemu"=truemun
                    , "obsD"=obs
                    , "l"=l
                    , "size"=size ))

}

# #for a fixed community 
# obscp<-function(l=l, size=size, dat=usersguide, B=2000, truemun=truemun...){
#   sam<-subsam(dat, size) #substample the whole community with # individuals=size
#   data.bt = rmultinom(B,size,Bt_prob_abu(sam)) #this genenerates "bootstrapped" samples, using Chao's fancy method
#   obs<-dfun(sam,l) #K. here we are just taking a single sample and computing the observed diversity
#   pro = apply(data.bt,2,function(boot)dfun(boot, l)) #This had been inconsistent with intent and was doing estimator stuff where we just wanted the naive answer.
#   pro_mc<-pro-mean(pro)+obs
#   chaotile_mc<-sum(pro_mc<=truemun)/(B/100)
#   chaotile<-sum(pro<=truemun)/(B/100)
#   return(data.frame("chaotile"=chaotile, "chaotile_mc"=chaotile_mc, "truemu"=truemun,  "obsD"=obs, "l"=l, "size"=size ))
# }

#set number of reps

truemun<-truemu_inf(SADs_list[[1]][[2]][[3]]$rel_abundances, size=200, reps=reps, l=0)

plan(strategy=multiprocess, workers=nc) #this is telling the computer to get ready for the future_ commands
quickout<-future_map_dfr(1:reps, function(reps){
  obscp_inf(l=0, 200, SADs_list[[1]][[2]][[3]], truemun=truemun, B=Bnum)}
)
quickout
quickout %>% ggplot(aes(p))+geom_histogram()+theme_classic()

####################
#run this whole thing to get sample diversity checkplot-type info for sample diversity for a single community
trycheckingobs<-function(SAD, size){
 
    map_dfr(c(-1,0,1), function(ell){
      truemun<-truemu_inf(SAD$rel_abundances, size=size, reps=reps, l=ell)
      future_map_dfr(1:reps, function(reps){obscp_inf(l=ell, size, SAD, truemun=truemun, B=Bnum)

    
    })
  })
}
##### apparently this was streamlined enough to store to a single .csv while running in parallel


map(c(1:24), function(SAD){
  
  mycode<-c(
    "source(\"scripts/checkplot_initials.R\")"
    ,  "source(\"scripts/obscp_inf.R\")"
    ,  "reps<-5e2"

    , "Bnum<-2e3"
    , "nc<-36 #scaling this back to work on amarel... suspect memory issues"
    , "plan(strategy=multisession, workers=nc)"
    , " map(round(10^seq(2, 3.5, 0.25)), function(size){"
    , "map(c(-1,0,1), function(ell){"
    , "map(1:100, function(tryme){"
    , "        start<-Sys.time()"
    , paste0("nd<-trycheckingobs(flatten(flatten(SADs_list))[[",SAD,"]], size, ell)")
    , paste0("write.csv(nd, file=paste(\"data/new_trycheckingobs_SAD_", SAD,"\", \"iter_\", tryme, \"size\", size, \".csv\", sep=\"\"), row.names=F)")
    , "rm(nd)"
    ,       "print(Sys.time()-start)"
    ,      "})"
    , "})"
    , "})"
    )
  
  write_lines(mycode, paste0("scripts/obs_lomemSAD", SAD, ".R"))
})




# write.csv(trycheckingobs_R, file="data/big_richness_checkplot.csv", row.names=F)

# write.csv(trycheckingobs, file="data/fromR/trycheckingobs_with_without_mc.csv", row.names=F)


##################################
# read in data and make checkplot for sample diveristy
# trycheckingobs<-read.csv("data/fromR/trycheckingobs_with_without_mc.csv")


# trycheckingobs<-read.csv("data/fromR/trycheckingobs_with_without_mc.csv")
sample_div_cp<-future_map_dfr(1:20, function(SAD){
  newdf<-read.csv(, file=paste("data/fromR/trycheckingobs_SAD_", SAD, ".csv", sep=""))
  return(data.frame(newdf, "SAD_index"=rep(SAD, length(newdf[,1]))))
})

sample_div_cp %>% filter(size==562) %>% ggplot(aes(obsD))+geom_density()+facet_grid(SAD_index~l)
unique(sample_div_cp$size)

# sample_div_cp<-future_map_dfr(1:20, function(SAD){
#   newdf<-read.csv(file=paste("data/fromR/fromR/trycheckingobs_SAD_", SAD, ".csv", sep=""))
#   return(data.frame(newdf, "SAD_index"=rep(SAD, length(newdf[,1]))))
# })
# 

# write.csv(sample_div_cp, "data/fromR/sample_diversity_checkplots.csv", row.names=F)


# sample_div_cp<-read.csv("data/fromR/trycheckingobs_SAD_3.csv")
# sample_div_cp<-read.csv("data/fromR/sample_diversity_checkplots.csv")
head(sample_div_cp)
#compute sd_logs for these
pdf("figures/variability_in_sample_diversity_extremes.pdf")
sample_div_cp %>% 
  left_join(data.frame(l=c(-1,0,1)
                       , hill=factor(c("Hill-Simpson", "Hill-Shannon", "Richness")
                                     , levels=c("Hill-Simpson", "Hill-Shannon", "Richness")))) %>% 
  left_join(data.frame(
    SAD_index=1:20
    , skew=factor(c("uneven", "int", "int","int", "even"), levels=c("uneven", "int", "even"))
    , dist=factor(c(rep("lognormal", 10), rep("gamma", 10)), levels=c("lognormal", "gamma"))
  )) %>% 
  filter(SAD_index %in% c(1, 11, 5, 15) )%>% 
  group_by(hill, size, skew, dist, SAD_index) %>% 
  summarize(sdlog=sd(log(obsD))) %>% 
  ggplot(aes(size, sdlog, color=hill, shape=hill))+
  geom_point(alpha=0.8)+
  geom_line(alpha=0.8)+
  scale_x_log10(breaks=trans_breaks("log10", function(x) 10^x),
                labels = trans_format("log10", math_format(10^.x)))+
  theme_classic()+
  # geom_hline(yintercept=0.1)+
  labs(x="sample size (individuals)"
       , y="SD of log(sample diversity) under random sampling"
       , color="", shape="" )+
  facet_grid(dist~skew)+
  theme(text=element_text(size=16))
dev.off()

#####################
#checkplot figure, not used in users guide, now does checkplot without mean correction. 
# pdf(file="figures/empirical_checkplot1_nomc.pdf")
# map(c(-1,0,1), function(ell){
#     trycheckingobs %>% filter(l==ell) %>% 
#         ggplot(aes(chaotile))+
#         geom_histogram()+
#         theme_classic()+
#         facet_wrap(~size+l)
# })
# dev.off()

pdf("figures/too_many_checkplots_sample_diversity.pdf")
future_map(1:40, function(SAD){
  map(-1:1, function(ell){
    sample_div_cp %>% filter(SAD_index==SAD, l==ell) %>% 
      ggplot(aes(chaotile_mc/100))+
      geom_histogram(breaks=seq(0, 1, by=0.025))+
      theme_classic()+
      facet_wrap(~size)+
      ggtitle(paste("SAD number", SAD, "ell =",ell))
  })
})

dev.off()

pdf("figures/too_many_checkplots_sample_diversity_limited_even.pdf")
# map(1:40, function(SAD){
map(-1:1, function(ell){
  sample_div_cp %>% filter(SAD_index==9, l==ell, size %in% round(10^seq(2,3,.25))) %>% 
    ggplot(aes(chaotile_mc))+
    geom_histogram()+
    theme_classic()+
    facet_wrap(~size)+
    ggtitle(paste("checkplot for sample Hill diveristy, ell =",ell))
})
# })

dev.off()

pdf("figures/too_many_checkplots_sample_diversity_limited.pdf")
# map(1:40, function(SAD){
map(-1:1, function(ell){
  map(1:4, function(SAD){
    sample_div_cp %>% filter(SAD_index==c(1,5,11,15)[SAD], l==ell, size %in% round(10^seq(2, 4, .5))) %>% 
      ggplot(aes(chaotile_mc/100))+
      geom_histogram()+
      theme_classic()+
      facet_wrap(~size)+
      ggtitle(paste("checkplot for sample "
                    , c("richness", "Hill-Shannon", "Hill-Simpson")[2-ell]
                    ,"; "
                    , c("lognormal; uneven","lognormal; even", "gamma; uneven", "gamma; even")[SAD] 
                    , sep=""
      ))+
      labs(x="p-value")
  })
})

dev.off()
####################################
# set up data for users guide figures
nreps<-5e3 #this should be 5000 for now

# #df with true coverage of 95% CI
# tvcov <-trycheckingobs %>% group_by(l, size) %>% summarize(outside=1-(sum(chaotile_mc>97.5)+sum(chaotile_mc<2.5))/(nreps*100))

#relable facets by creating new factor in df
inds<-data.frame("l"=c(1,0,-1), 
                 divind=factor(c("richness", "Hill-Shannon", "Hill-Simpson"),
                               levels=c("richness", "Hill-Shannon", "Hill-Simpson")
                 )
)

# tc<-left_join(tvcov, inds)
tc<-sample_div_cp %>% group_by(l, size, SAD_index) %>% summarize(outside=1-(sum(chaotile_mc>97.5)+sum(chaotile_mc<2.5))/(5000)) %>% left_join(inds)

tc

min(tc$outside)


#######################################
# extract data from files for use

# outerreps<-10
# sad_list_length<-20
# getug<-future_map_dfr(1:sad_list_length, function(x){
#   map_dfr(1:outerreps, function(y){
#     mydf<-tryCatch(read.csv(paste("data/SAD", x, "asy",  y, ".csv", sep="_")), error=function(e){
#       data.frame(qtile=NA, truediv=NA, chaoest=NA, obsD=NA, l=NA, inds=NA, reps=NA)})
#     mydf<-data.frame(mydf, SAD_ind=x)
#     return(mydf)
#     
#   })
#   
# })
plan(strategy=multiprocess, workers=7)
getug<-future_map_dfr(1:24, function(SAD){
 x<-read.csv(paste0("data/asy_SAD", SAD, ".csv")) 
 x %>% bind_cols(SAD_ind=rep(SAD, length(x[,2])))
})

<<<<<<< HEAD
getug2<-future_map_dfr(1:24, function(SAD){
  x<-read.csv(paste0("data/asy_SAD", SAD, "_other.csv")) 
  x %>% bind_cols(SAD_ind=rep(SAD, length(x[,2])))
})

getobs<-future_map_dfr(1:24, function(SAD){
  x<-read.csv(paste0("data/obs_SAD", SAD, ".csv")) 
  x %>% bind_cols(SAD_ind=rep(SAD, length(x[,2])))
})

#summarize SDlog(diversity) # for some reason this seems to be taking a long time isn't THAT much data is it?
sdlogs<-getug2  %>% 
=======

#summarize SDlog(diversity) # for some reason this seems to be taking a long time isn't THAT much data is it?
sdlogs<-getug  %>% 
>>>>>>> a9bc6c38c1d2521ff2203fe88bda2821b1ae992a
  gather(etype, div, chaoest, obsD ) %>% 
  group_by(l, inds, SAD_ind, etype) %>% 
  summarize(sdlog=sd(log(div), na.rm=T), cv=sd(div, na.rm=T)/mean(div, na.rm=T))


<<<<<<< HEAD
#repeat for obs only
sdlogs_O<-getobs  %>% 
  group_by(l, size, SAD_ind) %>% 
  summarize(sdlog=sd(log(obsD), na.rm=T), cv=sd(obsD, na.rm=T)/mean(obsD, na.rm=T))

=======
>>>>>>> a9bc6c38c1d2521ff2203fe88bda2821b1ae992a
# #maybe useful combining 
# #figure for MS possibly, showing how this works for even and uneven comms 
# pdf("figures/variability_in_asymptotic_diversity_extremes_test.pdf")
# sdlogs %>% 
#   filter(etype=="chaoest") %>%
#   left_join(data.frame(l=c(-1,0,1)
#                        , hill=factor(c("Hill-Simpson", "Hill-Shannon", "Richness")
#                                      , levels=c("Hill-Simpson", "Hill-Shannon", "Richness")))) %>% 
#   # left_join(data.frame(
#   #   SAD_ind=1:20
#   #   , skew=factor(c("uneven", "int", "int","int", "even"), levels=c("uneven", "int", "even"))
#   #   , dist=factor(c(rep("lognormal", 10), rep("gamma", 10)), levels=c("lognormal", "gamma"))
#   # )) %>% 
#   # filter(SAD_ind %in% c(1, 11, 5, 15) )%>% 
#   group_by(hill, inds, SAD_ind) %>% # skew, dist,
#   ggplot(aes(inds, sdlog, color=hill, shape=hill))+
#   geom_point(alpha=0.8)+
#   geom_line(alpha=0.8)+
#   scale_x_log10(breaks=trans_breaks("log10", function(x) 10^x),
#                 labels = trans_format("log10", math_format(10^.x)))+
#   theme_classic()+
#   # geom_hline(yintercept=0.1)+
#   labs(x="sample size (individuals)"
#        , y="SD of log(asymtptotic diversity) under random sampling"
#        , color="", shape="" )+
#   facet_grid(~SAD_ind)+
#   theme(text=element_text(size=16))
# dev.off()
# 
# 
# plot(sdlogs$sdlog, sdlogs$cv)
<<<<<<< HEAD
pdf(file="figures/sampling_variability_2.pdf")
=======
pdf(file="figures/sampling_variabilit.pdf")
>>>>>>> a9bc6c38c1d2521ff2203fe88bda2821b1ae992a
# future_map(c(1:4, 5:8, 9:12, 13:16, 17:20, 21:24), function(x){SAD_ind %in%x &
map(c("chaoest", "obsD"), function(et){
  dat<-sdlogs %>%
    filter(etype==et)
    tryCatch({
    dat %>% ggplot(aes(inds, sdlog, color=factor(l), shape=factor(l)))+
    geom_point()+
    geom_line()+
    facet_wrap(~SAD_ind, ncol=5)+
    theme_classic()+scale_x_log10()+
    theme(axis.text.x=element_text(angle=90))+
    # geom_hline(yintercept=0.1)+
<<<<<<< HEAD
    labs(x="sample size", y=paste0("SD of log(", et, ") under random sampling"))
=======
    labs(x="sample size", y="SD of log(asymptotic estimator) under random sampling")
>>>>>>> a9bc6c38c1d2521ff2203fe88bda2821b1ae992a
    })
})
  dev.off()
#look at SDlog of estimates
<<<<<<< HEAD
pdf("figures/ugly_variability_in_obsD.pdf")
sdlogs_O %>% ggplot(aes(size, sdlog, color=factor(l), shape=factor(l)))+
      geom_point()+
      geom_line()+
      facet_wrap(~SAD_ind, ncol=5)+
      theme_classic()+scale_x_log10()+
      theme(axis.text.x=element_text(angle=90))+
      # geom_hline(yintercept=0.1)+
      labs(x="sample size", y=paste0("SD of log(observed diversity) under random sampling"))
 
dev.off()
=======


>>>>>>> a9bc6c38c1d2521ff2203fe88bda2821b1ae992a
#this is a think to repeat probably. Note that code below is for users' guide. should clean up and separate
asycov<-getug%>% filter(SAD_ind==7) %>% 
  group_by(l, inds) %>% 
  summarize(outside=1-(sum(qtile>97.5)+sum(qtile<2.5))/(5000)) %>% left_join(inds)


###############################
# combine sample and saymptotic to make a single multi-panel graph 
comb_cov<-bind_rows("sample diversity"=tc %>% filter(SAD_index==7) %>% rename(inds=size), "asymptotic diversity"=asycov, .id="esttype" )
#code to generate plot
#to figure out y-axis breaks:  prettify(trans_breaks(arm::logit, invlogit, n=15)(c(0.5,0.9999999)))

##########################################
# figure for Users guide to show statistical coverage for asymptotic estimators and also sample diveristy CIs
pdf(file="figures/CI_coverage_guide.pdf", height=6, width=6) #

comb_cov %>% filter(inds<=10^4) %>% 
  mutate(conserv=log(outside/(1-outside))) %>% 
  ggplot(aes(inds, outside, color=conserv, shape=esttype))+
  geom_point(size=2)+
  
  geom_hline(yintercept=0.95)+
  facet_grid(divind~esttype, switch="y" )+#strip.position=NULL
  theme_classic()+
  scale_shape_manual(values=c(17,15))+
  scale_color_gradient2(low="red",mid="grey55", high="cyan", limits=c(-.6,6), midpoint=2.944, breaks=c(-.6,6), labels=c(" over-confident",  " conservative"))+
  scale_y_continuous(trans="logit", limits=c(0.3, .995), breaks=c(0.3,0.5, 0.73, 0.88, 0.95, 0.98,0.99, 0.995), labels=c(30,50, 73, 88, 95, 98, 99, 99.5))+ #modify this so that it doesn't go quite as high
  scale_x_log10(labels = trans_format("log10", math_format(10^.x)))+
  labs(y="% samples for which 95% CI contains true value", x="individuals")+
  theme(legend.title = element_blank()
        , panel.spacing=unit(1.3, "lines")
        , strip.placement.y = "outside"
        , strip.background = element_blank()#element_rect(fill="lightgrey", linetype=0)
        , strip.text=element_text(face="bold")
        # , strip.text.y = element_text(angle = 180)
        , legend.text=element_text(hjust=0.5)    )+
  guides(shape=F)

dev.off()


2^15

##########
# generate comms with 3 spp
nsamp<-5e2
maxr<-24

nc<-12
R_FUTURE_FORK_ENABLE<-T

plan(strategy=multiprocess, workers=nc)
library(tictoc)
tic()
myres<-future_map_dfr(1:maxr, function(rep){
  map_dfr(1:100, function(irep){
    A<-runif(1, 1/3, 1)
    B<-runif(1, (1-A)/2, 1-A)
    C<-1-A-B
    map_dfr(2^c(2:15), function(inds){
      mysams<-replicate(nsamp, sample_infinite(c(A,B,C), size=inds))
      sam_shan<-sd(log(unlist(apply(mysams, MARGIN=2, FUN=function(x){dfun(x, 0)}))), na.rm=T)
      sam_sim<-sd(log(unlist(apply(mysams, MARGIN=2, FUN=function(x){dfun(x, -1)}))), na.rm=T)
      return(data.frame(inds, sam_shan, sam_sim, A, B, C))
    })
  })
})
toc()

myres<-myres %>% rowwise(.) %>% 
  mutate(low=min(c(A,B,C)), mid=median(c(A,B,C)), high=max(c(A,B,C)), rulebreaker=sam_shan>sam_sim
         , Hill.Shannon=dfun(c(A,B,C),0), Hill.Simpson=dfun(c(A,B,C),-1))


myres %>% ggplot(aes(Hill.Shannon, Hill.Simpson, color=rulebreaker, shape=rulebreaker))+
  geom_point(alpha=0.02)+
  theme_classic()

pdf("figures/better_variability_plot.pdf")
myres %>% 
  left_join(myres %>% 
              group_by(low, mid) %>% 
              summarize(rb=sum(rulebreaker), rf=sum(!rulebreaker), purity=max(c(rb, rf))/14)) %>% 
  ggplot(aes(low/mid, mid/high, color=7.5-rf, shape=rulebreaker))+
  geom_point(alpha=0.05, size=3)+
  scale_color_gradient2()+
  guides(color=guide_colorbar("tendency to break the rules"))+
  theme_classic()


dev.off()

myres %>% ggplot(aes(inds, fill=rulebreaker))+geom_histogram(alpha=0.2, position="dodge")

