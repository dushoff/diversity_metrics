ampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:50, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.9)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>0)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank2<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
quartz()
plot(byrank2)
summary(lm(byrank2$V5.mean~byrank2$V3))
byrank2
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses jmult<-rnorm(20, mean=8.91, sd=1)#report<-data.frame()for(j in 1:length(mult)){#set number of iterations nfor(n in 1:5){#j<-1#set number of sitessnum<-15#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simri[which(simri
<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated)ncom<-50#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45######################################################################??????????WHAT DISTRIBUTIONS TO USE????????
????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect trans_abundance_mean<-rlnorm(n=1, mean=setmean)trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance[k], replace=TRU
E, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sitesx[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 10:50){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:5){	#Set up some tables and counters for subsampling#row label for subs
ampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:50, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.9)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>0)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank3<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses jmult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()for(j in 1:length(mult)){#set number of iterations nfor(n in 1:5){#j<-1#set number of sitessnum<-15#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simri[which(simri
<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated)ncom<-50#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45######################################################################??????????WHAT DISTRIBUTIONS TO USE????????
????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect trans_abundance_mean<-rlnorm(n=1, mean=setmean)trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance[k], replace=TRU
E, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sitesx[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 10:50){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:5){	#Set up some tables and counters for subsampling#row label for subs
ampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:50, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.9)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>0)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
quartz()
plot(byrank3)
quartz()
plot(byrank4)
summary(lm(byrank4$V5.mean~byrank4$V3))
byrank4
byrank4<-byrank4[which(byrank4$V5.mean != -Inf)]
byrank4<-byrank4[which(byrank4$V5.mean != -Inf),]
summary(lm(byrank4$V5.mean~byrank4$V3))
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses jmult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()for(j in 1:length(mult)){#set number of iterations nfor(n in 1:10){#j<-1#set number of sitessnum<-15#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simri[which(simr
i<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated)ncom<-50#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45######################################################################??????????WHAT DISTRIBUTIONS TO USE???????
?????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect trans_abundance_mean<-rlnorm(n=1, mean=setmean)trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance[k], replace=TR
UE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sitesx[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 10:50){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:10){	#Set up some tables and counters for subsampling#row label for sub
sampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:50, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.9)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>0)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
byrank
plot(byrank4)
byrank4
summary(lm(byrank4$V5.mean~byrank4$V3))
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses jmult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()for(j in 1:length(mult)){#set number of iterations nfor(n in 1:30){#j<-1#set number of sitessnum<-15#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simri[which(simr
i<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated)ncom<-50#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45######################################################################??????????WHAT DISTRIBUTIONS TO USE???????
?????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect trans_abundance_mean<-rlnorm(n=1, mean=setmean)trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance[k], replace=TR
UE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sitesx[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 10:50){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:30){	#Set up some tables and counters for subsampling#row label for sub
sampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:50, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.9)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>0)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
plot(byrank4)
byrank4<-byrank4[which(byrank4$V5.mean != -Inf),]
summary(lm(byrank4$V5.mean~byrank4$V3))
x[1]
rowsums(x[1])
rowSums(x[1])
x1<-as.data.frame(x[1])
rowSums(x1)
colSums(x1)
x5<-as.data.frame(x[5])
colSums(x5)
rowSums(x5)
test
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_CA#
ObsRaw <- ObsRaw_CA#
SpecRaw <- SpecRaw_CA#
#ObsRaw <- subset(ObsRaw_MI, year == "2013")#
#SpecRaw <- subset(SpecRaw_MI, treatment !="NA" & year =="2013")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
#SpecRaw<-subset(SpecRaw_NJ, treatment!="NA" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', main= "Observed abundance and specimen richness, NJ 2011"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$#
### lots or part 1 stolen From Kraft et al. Science 2011#
##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$#
#
## R code- PART 1#
## Simulation to assemble communities at random from#
## given total abundance, richness, dsitributing individuals among species and among transects#
##generates output matrices of site- and transect- richness and abundance (both P/A and raw #
## abundance forms possible#
## PART 2 takes these output results and subsamples the transects to and compares how #
#richness of subsample of#
## transects predicts richness at the full site (ranking)#
## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #
#it takes the effort required to reach a correlation of 0.9 #
##in the second part (the inner loop), #
#and generates graphs of how the x-coordinates #
## varies with the varaibility over which the #
############################################
########### PART 1 #########################
############################################
library(doBy)#
library(Hmisc)#
library(reshape)#
threshtab<-data.frame()#
counter<-0#
#set scale for SD of richnesses j#
mult<-rnorm(20, mean=8.91, sd=3)#
#report<-data.frame()#
for(j in 1:length(mult)){#
#set number of iterations n#
for(n in 1:10){#
#j<-1#
#set number of sites#
snum<-10#
#generate simulated site abundances with mean from specimen, using lognormal#
#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))#
#
###################################################################
####??????????WHAT DISTRIBUTIONS TO USE????????????????############
#################################################################
#
#generate simulated richnesses with mean, SD from specimen, using a normal distribution#
#specimen richness mean, SD 18.79, 8.91#
rmean<-18.79#
#rsd<-8.91/(1+log(j))#
rsd<-mult[j]#
simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#
#set negative results to 1#
simri[which(simri<1)]<-1#
#
#this was to visualize the simulated data alongside the observed data#
# quartz()#
# hist(simri, breaks=9)#
# quartz()#
# hist(specimen$specrich, breaks=12)#
# quartz()#
# hist(simab)#
# quartz()#
# hist(specimen$specabund)#
#
##########################
## start of simulation ###
##########################
## vector of site richnesses, here set to simulated from normal distribution:#
gamma_vect=simri#
## transects per site (simulated)#
ncom<-50#
#lots of arrays to set to null before loop#
gamma_obs<-NULL #reset variables from prior simulations#
means<-NULL ##
x<-list()#
vars<-NULL ##
gamma<-NULL ##
stems<-NULL ##
poollike<-data.frame()#
gamma_obs<-NULL ##
mean_alpha<-NULL ##
output<-data.frame()#
corlab<-0#
#Add empty df to populate with subsampling outputs#
abuncor<-data.frame()#
# i is site id#
for(i in 1:snum){#
##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) #
setmean<-4.45#
#
###################################################################
####??????????WHAT DISTRIBUTIONS TO USE????????????????############
#################################################################
#
## drawn from a with mean log normal, then drawn from another log normal #
##for each each transect #
#trans_abundance_mean<-rlnorm(n=1, mean=setmean)#
#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#
#try fixing abundance to richness#
trans_abundance_mean<-(20*gamma_vect[i]-10)/50#
trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#
## Then assign proportions of individuals to which to assign each species identity, #
## again drawn from log normal#
occur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity#
#
## build an empty species by site matrix to hold the data#
           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,#
ncol=gamma_vect[i])->results#
           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))#
           ## populate each transect (row of matrix) by#
#sampling individuals with replacement#
   ## from the species pool; k is index for TRANSECTS, i for SITES#
           for(k in 1:ncom){#
               local<-sample(1:gamma_vect[i],#
size=trans_abundance[k], replace=TRUE, prob=occur)#
               table(local)->tab#
   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab#
}#ends loop to generate a single "site" community, indexed by k#
#
# for a site, a set of transects with species id, richness, and abundance.#
       ## remove any species from the species by site matrix#
#that do not occur in any community:#
       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){#
                results[,-(which(apply(results, MARGIN=2,#
FUN=sum)==0))]->results#
                } #ends if function#
       ## convert the abundance-based species by site matrix#
#into a presence/ absence matrix:#
       results->occur_mat#
       occur_mat[occur_mat>0]<-1#
       ## calculate the number of species present in each transect (alphas):#
       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance#
      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs#
       #poolstart<-cbind(i, alphas, trab)#
      # poollike<-rbind(poollike, poolstart)#
       ## richness of sites (all transects combined):#
       gamma_observed<-ncol(results)#
       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites#
x[[i]]<-occur_mat#
# counter<-counter+1 #remove when uncommenting next loop#
# report[counter,"site"]<-i		#
# report[counter,"iteration"]<-n#
# report[counter,"sdinput"]<-j#
# report[counter,"realizedsd"]<-sd(gamma_obs)#
#
} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)#
#
################################
########## Part 2 $################
#################
#
#This sections subsamples the transects from the artificial sites generated above.#
#
#w is number of transects to include in a sample#
for(w in 1:50){	#
# m is number of iterations, and larger numbers will slow down script#
for(m in 1:10){	#
#
#Set up some tables and counters for subsampling#
#row label for subsampling#
0->rlab#
#Empty array to populate with subsampling for loop#
Rabund<-array(dim=c(snum,6))#
Rabund<-data.frame(Rabund)	#
# iterate over i sites#
for(i in 1:snum){#
rlab<-rlab+1#
#
#sample w subsamples (transects) of simulated sites #
smpl<-sample(1:50, size=w, replace=F)#
ba<-x[[i]]#
subsam<-ba[smpl,, drop=FALSE]#
if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){#
                results[,-(which(apply(results, MARGIN=2,#
FUN=sum)==0))]->subsam#
                }#
#populate array for step in loop- for each site i for each iteration m#
# first column is site#
Rabund[rlab, 1]<-i#
#second column for size of sample (DPC...Number of Transects correct?)#
Rabund[rlab, 2]<-w#
# third column is the richness of site based on sampled transects#
Rabund[rlab, 3]<-ncol(subsam) #
#fourth is native bee richness in simulated sites (all transects)#
Rabund[rlab,4]<-gamma_obs[i]#
#
} #Ends for i sites, #
#Create table of correlations for each number of sections for each iteration#
corlab<-corlab+1#
abuncor[corlab,1]<-w#
Rabund[,5]<-rank(Rabund[,3]) #rank based on subsample#
Rabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"#
cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]#
abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])#
} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))#
#
thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.9)])#
ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>0)])#
counter<-counter+1#
threshtab[counter,1]<-j#
threshtab[counter,2]<-mult[j]#
threshtab[counter,3]<-rsd#
threshtab[counter,4]<-thresh#
threshtab[counter,5] <-ranks#
#
} #ends for n, or each iteration of the whole loop at an SD level#
} #ends for j#
byrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)#
ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #
#V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)#
########################
#END Subsampling
plot(ANSWER)
plot(byrank4)
summary(lm(ANSWER$V5.mean~ANSWER4$V3))
summary(lm(ANSWER$V5.mean~ANSWER$V3))
ANSWER
byrank4
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$#
### lots or part 1 stolen From Kraft et al. Science 2011#
##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$#
#
## R code- PART 1#
## Simulation to assemble communities at random from#
## given total abundance, richness, dsitributing individuals among species and among transects#
##generates output matrices of site- and transect- richness and abundance (both P/A and raw #
## abundance forms possible#
## PART 2 takes these output results and subsamples the transects to and compares how #
#richness of subsample of#
## transects predicts richness at the full site (ranking)#
## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #
#it takes the effort required to reach a correlation of 0.9 #
##in the second part (the inner loop), #
#and generates graphs of how the x-coordinates #
## varies with the varaibility over which the #
############################################
########### PART 1 #########################
############################################
library(doBy)#
library(Hmisc)#
library(reshape)#
threshtab<-data.frame()#
counter<-0#
#set scale for SD of richnesses j#
mult<-rnorm(20, mean=8.91, sd=3)#
#report<-data.frame()#
for(j in 1:length(mult)){#
#set number of iterations n#
for(n in 1:10){#
#j<-1#
#set number of sites#
snum<-10#
#generate simulated site abundances with mean from specimen, using lognormal#
#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))#
#
###################################################################
####??????????WHAT DISTRIBUTIONS TO USE????????????????############
#################################################################
#
#generate simulated richnesses with mean, SD from specimen, using a normal distribution#
#specimen richness mean, SD 18.79, 8.91#
rmean<-18.79#
#rsd<-8.91/(1+log(j))#
rsd<-mult[j]#
simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#
#set negative results to 1#
simri[which(simri<1)]<-1#
#
#this was to visualize the simulated data alongside the observed data#
# quartz()#
# hist(simri, breaks=9)#
# quartz()#
# hist(specimen$specrich, breaks=12)#
# quartz()#
# hist(simab)#
# quartz()#
# hist(specimen$specabund)#
#
##########################
## start of simulation ###
##########################
## vector of site richnesses, here set to simulated from normal distribution:#
gamma_vect=simri#
## transects per site (simulated)#
ncom<-50#
#lots of arrays to set to null before loop#
gamma_obs<-NULL #reset variables from prior simulations#
means<-NULL ##
x<-list()#
vars<-NULL ##
gamma<-NULL ##
stems<-NULL ##
poollike<-data.frame()#
gamma_obs<-NULL ##
mean_alpha<-NULL ##
output<-data.frame()#
corlab<-0#
#Add empty df to populate with subsampling outputs#
abuncor<-data.frame()#
# i is site id#
for(i in 1:snum){#
##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) #
setmean<-4.45#
#
###################################################################
####??????????WHAT DISTRIBUTIONS TO USE????????????????############
#################################################################
#
## drawn from a with mean log normal, then drawn from another log normal #
##for each each transect #
#trans_abundance_mean<-rlnorm(n=1, mean=setmean)#
#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#
#try fixing abundance to richness#
trans_abundance_mean<-(20*gamma_vect[i]-10)/50#
trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#
## Then assign proportions of individuals to which to assign each species identity, #
## again drawn from log normal#
occur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity#
#
## build an empty species by site matrix to hold the data#
           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,#
ncol=gamma_vect[i])->results#
           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))#
           ## populate each transect (row of matrix) by#
#sampling individuals with replacement#
   ## from the species pool; k is index for TRANSECTS, i for SITES#
           for(k in 1:ncom){#
               local<-sample(1:gamma_vect[i],#
size=trans_abundance[k], replace=TRUE, prob=occur)#
               table(local)->tab#
   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab#
}#ends loop to generate a single "site" community, indexed by k#
#
# for a site, a set of transects with species id, richness, and abundance.#
       ## remove any species from the species by site matrix#
#that do not occur in any community:#
       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){#
                results[,-(which(apply(results, MARGIN=2,#
FUN=sum)==0))]->results#
                } #ends if function#
       ## convert the abundance-based species by site matrix#
#into a presence/ absence matrix:#
       results->occur_mat#
       occur_mat[occur_mat>0]<-1#
       ## calculate the number of species present in each transect (alphas):#
       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance#
      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs#
       #poolstart<-cbind(i, alphas, trab)#
      # poollike<-rbind(poollike, poolstart)#
       ## richness of sites (all transects combined):#
       gamma_observed<-ncol(results)#
       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites#
x[[i]]<-occur_mat#
# counter<-counter+1 #remove when uncommenting next loop#
# report[counter,"site"]<-i		#
# report[counter,"iteration"]<-n#
# report[counter,"sdinput"]<-j#
# report[counter,"realizedsd"]<-sd(gamma_obs)#
#
} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)#
#
################################
########## Part 2 $################
#################
#
#This sections subsamples the transects from the artificial sites generated above.#
#
#w is number of transects to include in a sample#
for(w in 1:50){	#
# m is number of iterations, and larger numbers will slow down script#
for(m in 1:10){	#
#
#Set up some tables and counters for subsampling#
#row label for subsampling#
0->rlab#
#Empty array to populate with subsampling for loop#
Rabund<-array(dim=c(snum,6))#
Rabund<-data.frame(Rabund)	#
# iterate over i sites#
for(i in 1:snum){#
rlab<-rlab+1#
#
#sample w subsamples (transects) of simulated sites #
smpl<-sample(1:50, size=w, replace=F)#
ba<-x[[i]]#
subsam<-ba[smpl,, drop=FALSE]#
if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){#
                results[,-(which(apply(results, MARGIN=2,#
FUN=sum)==0))]->subsam#
                }#
#populate array for step in loop- for each site i for each iteration m#
# first column is site#
Rabund[rlab, 1]<-i#
#second column for size of sample (DPC...Number of Transects correct?)#
Rabund[rlab, 2]<-w#
# third column is the richness of site based on sampled transects#
Rabund[rlab, 3]<-ncol(subsam) #
#fourth is native bee richness in simulated sites (all transects)#
Rabund[rlab,4]<-gamma_obs[i]#
#
} #Ends for i sites, #
#Create table of correlations for each number of sections for each iteration#
corlab<-corlab+1#
abuncor[corlab,1]<-w#
Rabund[,5]<-rank(Rabund[,3]) #rank based on subsample#
Rabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"#
cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]#
abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])#
} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))#
#
thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])#
ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1)])#
counter<-counter+1#
threshtab[counter,1]<-j#
threshtab[counter,2]<-mult[j]#
threshtab[counter,3]<-rsd#
threshtab[counter,4]<-thresh#
threshtab[counter,5] <-ranks#
#
} #ends for n, or each iteration of the whole loop at an SD level#
} #ends for j#
byrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)#
ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #
#V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)#
########################
#END Subsampling
ANSWER
trans_abundance
gamma_vect
i
occur
gamma_vect[i]
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$#
### lots or part 1 stolen From Kraft et al. Science 2011#
##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$#
#
## R code- PART 1#
## Simulation to assemble communities at random from#
## given total abundance, richness, dsitributing individuals among species and among transects#
##generates output matrices of site- and transect- richness and abundance (both P/A and raw #
## abundance forms possible#
## PART 2 takes these output results and subsamples the transects to and compares how #
#richness of subsample of#
## transects predicts richness at the full site (ranking)#
## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #
#it takes the effort required to reach a correlation of 0.9 #
##in the second part (the inner loop), #
#and generates graphs of how the x-coordinates #
## varies with the varaibility over which the #
############################################
########### PART 1 #########################
############################################
library(doBy)#
library(Hmisc)#
library(reshape)#
threshtab<-data.frame()#
counter<-0#
#set scale for SD of richnesses j#
mult<-rnorm(20, mean=8.91, sd=3)#
#report<-data.frame()#
for(j in 1:length(mult)){#
#set number of iterations n#
for(n in 1:10){#
#j<-1#
#set number of sites#
snum<-10#
#generate simulated site abundances with mean from specimen, using lognormal#
#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))#
#
###################################################################
####??????????WHAT DISTRIBUTIONS TO USE????????????????############
#################################################################
#
#generate simulated richnesses with mean, SD from specimen, using a normal distribution#
#specimen richness mean, SD 18.79, 8.91#
rmean<-18.79#
#rsd<-8.91/(1+log(j))#
rsd<-mult[j]#
simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#
#set negative results to 1#
simri[which(simri<1)]<-1#
#
#this was to visualize the simulated data alongside the observed data#
# quartz()#
# hist(simri, breaks=9)#
# quartz()#
# hist(specimen$specrich, breaks=12)#
# quartz()#
# hist(simab)#
# quartz()#
# hist(specimen$specabund)#
#
##########################
## start of simulation ###
##########################
## vector of site richnesses, here set to simulated from normal distribution:#
gamma_vect=simri#
## transects per site (simulated)#
ncom<-50#
#lots of arrays to set to null before loop#
gamma_obs<-NULL #reset variables from prior simulations#
means<-NULL ##
x<-list()#
vars<-NULL ##
gamma<-NULL ##
stems<-NULL ##
poollike<-data.frame()#
gamma_obs<-NULL ##
mean_alpha<-NULL ##
output<-data.frame()#
corlab<-0#
#Add empty df to populate with subsampling outputs#
abuncor<-data.frame()#
# i is site id#
for(i in 1:snum){#
##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) #
setmean<-4.45#
#
###################################################################
####??????????WHAT DISTRIBUTIONS TO USE????????????????############
#################################################################
#
## drawn from a with mean log normal, then drawn from another log normal #
##for each each transect #
#trans_abundance_mean<-rlnorm(n=1, mean=setmean)#
#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#
#try fixing abundance to richness#
trans_abundance_mean<-(20*gamma_vect[i]-10)/50#
trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#
## Then assign proportions of individuals to which to assign each species identity, #
## again drawn from log normal#
occur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity#
#
## build an empty species by site matrix to hold the data#
           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,#
ncol=gamma_vect[i])->results#
           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))#
           ## populate each transect (row of matrix) by#
#sampling individuals with replacement#
   ## from the species pool; k is index for TRANSECTS, i for SITES#
           for(k in 1:ncom){#
               local<-sample(1:gamma_vect[i],#
size=trans_abundance[k], replace=TRUE, prob=occur)#
               table(local)->tab#
   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab#
}#ends loop to generate a single "site" community, indexed by k#
#
# for a site, a set of transects with species id, richness, and abundance.#
       ## remove any species from the species by site matrix#
#that do not occur in any community:#
       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){#
                results[,-(which(apply(results, MARGIN=2,#
FUN=sum)==0))]->results#
                } #ends if function#
       ## convert the abundance-based species by site matrix#
#into a presence/ absence matrix:#
       results->occur_mat#
       occur_mat[occur_mat>0]<-1#
       ## calculate the number of species present in each transect (alphas):#
       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance#
      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs#
       #poolstart<-cbind(i, alphas, trab)#
      # poollike<-rbind(poollike, poolstart)#
       ## richness of sites (all transects combined):#
       gamma_observed<-ncol(results)#
       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites#
x[[i]]<-occur_mat#
# counter<-counter+1 #remove when uncommenting next loop#
# report[counter,"site"]<-i		#
# report[counter,"iteration"]<-n#
# report[counter,"sdinput"]<-j#
# report[counter,"realizedsd"]<-sd(gamma_obs)#
#
} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)#
#
################################
########## Part 2 $################
#################
#
#This sections subsamples the transects from the artificial sites generated above.#
#
#w is number of transects to include in a sample#
for(w in 1:50){	#
# m is number of iterations, and larger numbers will slow down script#
for(m in 1:10){	#
#
#Set up some tables and counters for subsampling#
#row label for subsampling#
0->rlab#
#Empty array to populate with subsampling for loop#
Rabund<-array(dim=c(snum,6))#
Rabund<-data.frame(Rabund)	#
# iterate over i sites#
for(i in 1:snum){#
rlab<-rlab+1#
#
#sample w subsamples (transects) of simulated sites #
smpl<-sample(1:50, size=w, replace=F)#
ba<-x[[i]]#
subsam<-ba[smpl,, drop=FALSE]#
if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){#
                results[,-(which(apply(results, MARGIN=2,#
FUN=sum)==0))]->subsam#
                }#
#populate array for step in loop- for each site i for each iteration m#
# first column is site#
Rabund[rlab, 1]<-i#
#second column for size of sample (DPC...Number of Transects correct?)#
Rabund[rlab, 2]<-w#
# third column is the richness of site based on sampled transects#
Rabund[rlab, 3]<-ncol(subsam) #
#fourth is native bee richness in simulated sites (all transects)#
Rabund[rlab,4]<-gamma_obs[i]#
#
} #Ends for i sites, #
#Create table of correlations for each number of sections for each iteration#
corlab<-corlab+1#
abuncor[corlab,1]<-w#
Rabund[,5]<-rank(Rabund[,3]) #rank based on subsample#
Rabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"#
cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]#
abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])#
} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))#
#
thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])#
ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1)])#
counter<-counter+1#
threshtab[counter,1]<-j#
threshtab[counter,2]<-mult[j]#
threshtab[counter,3]<-rsd#
threshtab[counter,4]<-thresh#
threshtab[counter,5] <-ranks#
#
} #ends for n, or each iteration of the whole loop at an SD level#
} #ends for j#
byrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)#
ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #
#V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)#
########################
#END Subsampling
ANSWER
plot(ANSWER)
plot(byrank4)
byrank4
summary(lm(ANSWER$V5.mean~ANSWER$V3))
summary(lm(ANSWER$V4.mean~ANSWER$V3))
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$#
### lots or part 1 stolen From Kraft et al. Science 2011#
##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$#
#
## R code- PART 1#
## Simulation to assemble communities at random from#
## given total abundance, richness, dsitributing individuals among species and among transects#
##generates output matrices of site- and transect- richness and abundance (both P/A and raw #
## abundance forms possible#
## PART 2 takes these output results and subsamples the transects to and compares how #
#richness of subsample of#
## transects predicts richness at the full site (ranking)#
## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #
#it takes the effort required to reach a correlation of 0.9 #
##in the second part (the inner loop), #
#and generates graphs of how the x-coordinates #
## varies with the varaibility over which the #
############################################
########### PART 1 #########################
############################################
library(doBy)#
library(Hmisc)#
library(reshape)#
threshtab<-data.frame()#
counter<-0#
#set scale for SD of richnesses j#
mult<-rnorm(20, mean=8.91, sd=3)#
#report<-data.frame()#
for(j in 1:length(mult)){#
#set number of iterations n#
for(n in 1:10){#
#j<-1#
#set number of sites#
snum<-10#
#generate simulated site abundances with mean from specimen, using lognormal#
#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))#
#
###################################################################
####??????????WHAT DISTRIBUTIONS TO USE????????????????############
#################################################################
#
#generate simulated richnesses with mean, SD from specimen, using a normal distribution#
#specimen richness mean, SD 18.79, 8.91#
rmean<-18.79#
#rsd<-8.91/(1+log(j))#
rsd<-mult[j]#
simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#
#set negative results to 1#
simri[which(simri<1)]<-1#
#
#this was to visualize the simulated data alongside the observed data#
# quartz()#
# hist(simri, breaks=9)#
# quartz()#
# hist(specimen$specrich, breaks=12)#
# quartz()#
# hist(simab)#
# quartz()#
# hist(specimen$specabund)#
#
##########################
## start of simulation ###
##########################
## vector of site richnesses, here set to simulated from normal distribution:#
gamma_vect=simri#
## transects per site (simulated)#
ncom<-50#
#lots of arrays to set to null before loop#
gamma_obs<-NULL #reset variables from prior simulations#
means<-NULL ##
x<-list()#
vars<-NULL ##
gamma<-NULL ##
stems<-NULL ##
poollike<-data.frame()#
gamma_obs<-NULL ##
mean_alpha<-NULL ##
output<-data.frame()#
corlab<-0#
#Add empty df to populate with subsampling outputs#
abuncor<-data.frame()#
# i is site id#
for(i in 1:snum){#
##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) #
setmean<-4.45#
#
###################################################################
####??????????WHAT DISTRIBUTIONS TO USE????????????????############
#################################################################
#
## drawn from a with mean log normal, then drawn from another log normal #
##for each each transect #
#trans_abundance_mean<-rlnorm(n=1, mean=setmean)#
#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#
#try fixing abundance to richness#
trans_abundance_mean<-(20*gamma_vect[i]-10)/50#
trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#
## Then assign proportions of individuals to which to assign each species identity, #
## again drawn from log normal#
occur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity#
#
## build an empty species by site matrix to hold the data#
           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,#
ncol=gamma_vect[i])->results#
           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))#
           ## populate each transect (row of matrix) by#
#sampling individuals with replacement#
   ## from the species pool; k is index for TRANSECTS, i for SITES#
           for(k in 1:ncom){#
               local<-sample(1:gamma_vect[i],#
size=trans_abundance[k], replace=TRUE, prob=occur)#
               table(local)->tab#
   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab#
}#ends loop to generate a single "site" community, indexed by k#
#
# for a site, a set of transects with species id, richness, and abundance.#
       ## remove any species from the species by site matrix#
#that do not occur in any community:#
       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){#
                results[,-(which(apply(results, MARGIN=2,#
FUN=sum)==0))]->results#
                } #ends if function#
       ## convert the abundance-based species by site matrix#
#into a presence/ absence matrix:#
       results->occur_mat#
       occur_mat[occur_mat>0]<-1#
       ## calculate the number of species present in each transect (alphas):#
       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance#
      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs#
       #poolstart<-cbind(i, alphas, trab)#
      # poollike<-rbind(poollike, poolstart)#
       ## richness of sites (all transects combined):#
       gamma_observed<-ncol(results)#
       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites#
x[[i]]<-occur_mat#
# counter<-counter+1 #remove when uncommenting next loop#
# report[counter,"site"]<-i		#
# report[counter,"iteration"]<-n#
# report[counter,"sdinput"]<-j#
# report[counter,"realizedsd"]<-sd(gamma_obs)#
#
} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)#
#
################################
########## Part 2 $################
#################
#
#This sections subsamples the transects from the artificial sites generated above.#
#
#w is number of transects to include in a sample#
for(w in 1:50){	#
# m is number of iterations, and larger numbers will slow down script#
for(m in 1:10){	#
#
#Set up some tables and counters for subsampling#
#row label for subsampling#
0->rlab#
#Empty array to populate with subsampling for loop#
Rabund<-array(dim=c(snum,6))#
Rabund<-data.frame(Rabund)	#
# iterate over i sites#
for(i in 1:snum){#
rlab<-rlab+1#
#
#sample w subsamples (transects) of simulated sites #
smpl<-sample(1:50, size=w, replace=F)#
ba<-x[[i]]#
subsam<-ba[smpl,, drop=FALSE]#
if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){#
                results[,-(which(apply(results, MARGIN=2,#
FUN=sum)==0))]->subsam#
                }#
#populate array for step in loop- for each site i for each iteration m#
# first column is site#
Rabund[rlab, 1]<-i#
#second column for size of sample (DPC...Number of Transects correct?)#
Rabund[rlab, 2]<-w#
# third column is the richness of site based on sampled transects#
Rabund[rlab, 3]<-ncol(subsam) #
#fourth is native bee richness in simulated sites (all transects)#
Rabund[rlab,4]<-gamma_obs[i]#
#
} #Ends for i sites, #
#Create table of correlations for each number of sections for each iteration#
corlab<-corlab+1#
abuncor[corlab,1]<-w#
Rabund[,5]<-rank(Rabund[,3]) #rank based on subsample#
Rabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"#
cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]#
abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])#
} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))#
#
thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])#
ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])#
counter<-counter+1#
threshtab[counter,1]<-j#
threshtab[counter,2]<-mult[j]#
threshtab[counter,3]<-rsd#
threshtab[counter,4]<-thresh#
threshtab[counter,5] <-ranks#
#
} #ends for n, or each iteration of the whole loop at an SD level#
} #ends for j#
byrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)#
ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #
#V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)#
########################
#END Subsampling
summary(lm(ANSWER$V5.mean~ANSWER$V3))
summary(lm(ANSWER$V4.mean~ANSWER$V3))
answer
ANSWER
occur
occur_mat
threshtab
i
j
warnings
warnings()
trans_abundance
ba
str(ba)
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses jmult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()for(j in 1:length(mult)){#set number of iterations nfor(n in 1:10){#j<-1#set number of sitessnum<-10#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simri[which(simr
i<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated)ncom<-50#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45######################################################################??????????WHAT DISTRIBUTIONS TO USE???????
?????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richnesstrans_abundance_mean<-(20*gamma_vect[i]-10)/50trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k i
s index for TRANSECTS, i for SITES           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance[k], replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:50){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:10){	#Set up some tables and c
ounters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:50, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
ANSWER
plot(ANSWER)
summary(lm(ANSWER$V4.mean~ANSWER$V3))
plot(byrank4)
byrank
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses jmult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()for(j in 1:length(mult)){#set number of iterations nfor(n in 1:20){#j<-1#set number of sitessnum<-35#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-trunc(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simri[which(simr
i<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated)ncom<-50#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45######################################################################??????????WHAT DISTRIBUTIONS TO USE???????
?????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richnesstrans_abundance_mean<-(20*gamma_vect[i]-10)/50trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k i
s index for TRANSECTS, i for SITES           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance[k], replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:50){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:50){	#Set up some tables and c
ounters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:50, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
plot(ANSWER)
plot(byrank4)
plot(ANSWER)
summary(lm(ANSWER$V4.mean~ANSWER$V3))
ANSWER
ANSWER<-ANSWER[which(ANSWER$V4.mean != -Inf),]
summary(lm(ANSWER$V4.mean~ANSWER$V3))
plot(ANSWER)
plot(ANSWER, xlab="SD of site richness", ylab="mean # transects for r>0.8 \n with full site for richness", br="\n")
plot(ANSWER, xlab="SD of site richness", ylab="mean # transects for r>0.8 \n with full site for richness", break="\n")
plot(ANSWER, xlab="SD of site richness", ylab="mean # transects for r>0.8 with full site for richness")
plot(ANSWER, xlab="SD of site richness", ylab="mean # transects for r>0.8 with full site for richness", lwd=8)
box(lwd=5)
plot(ANSWER, xlab="SD of site richness", ylab="mean # transects for r>0.8 with full site for richness")
box(lwd=4)
abline(lm(ANSWER$V4.mean~ANSWER$V3), col=red, lwd=3)
abline(lm(ANSWER$V4.mean~ANSWER$V3), col="Red", lwd=3)
trans_abundance
?round
threstab
threshtab
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
ObsRaw <- ObsRaw_NJ#
SpecRaw <- SpecRaw_NJ#
ObsRaw <- subset(ObsRaw_NJ, year == "2011")#
SpecRaw <- subset(SpecRaw_NJ, year =="2011")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
#SpecRaw<-subset(SpecRaw_NJ, treatment!="NA" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
ObsRaw <- ObsRaw_NJ#
SpecRaw <- SpecRaw_NJ#
ObsRaw <- subset(ObsRaw_NJ, year == "2011")#
SpecRaw <- subset(SpecRaw_NJ, year =="2011")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, treatment!="NA" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', main= "Observed abundance and specimen richness, NJ 2011"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
ObsRaw <- ObsRaw_NJ#
SpecRaw <- SpecRaw_NJ#
ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, treatment!="NA" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', main= "Observed abundance and specimen richness, NJ 2012"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
ObsRaw <- ObsRaw_NJ#
SpecRaw <- SpecRaw_NJ#
ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, treatment!="NA" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', main= "Observed abundance and specimen richness, NJ 2012"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, treatment!="NA", year=="2012" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', main= "Observed abundance and specimen richness, NJ 2012"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, treatment!="NA", year=="2012" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
specRaw
SpecRaw
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, treatment!="NA" year=="2012" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', main= "Observed abundance and specimen richness, NJ 2012"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
specimen
SpecRaw
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, treatment!="NA"& year=="2012" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', main= "Observed abundance and specimen richness, NJ 2012"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
specimen
observed
richabund
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', main= "Observed abundance and specimen richness, NJ 2012"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, treatment!="NA"& year=="2011" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2011" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ 2011"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, treatment!="NA"& year=="2013" & site !="MO")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2013" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ 2013"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ,  year=="2013")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2013")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ 2013"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, year=="2013")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2013")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
SpecRaw
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, year=="2013")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2013" & project=="NCIG")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, year=="2013")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ 2013"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
str(specimen)
str(SpecRaw)
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
SpecRaw<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2013")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ 2013"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
specimen
specabund
richabund
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")#
2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")#
2011<-subset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")#
SpecRaw<-rbind(2011,2012,2013)#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, site!="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
2011
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")#
s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")#
s.2011<-subset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")#
SpecRaw<-rbind(s.2011,s.2012,s.2013)#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, site!="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dan.cariveau@gmail.com)#
 #This script graphs observed abundance and richness on the x and specimen richness and#
 #abundance on the y- all rounds, transects within treatment, and time of day combined for each site#
 #This script also prints pearson's correlations (r) rather than r2. #
#
#create panel for plots#
#par(mfrow=c(2,2))#
#
#create plots with fitlines, reporting r and slope of fit line#
#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ all years"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #
# #graph 4: observed richness, specimen abundance#
# quartz()#
# with(richabund, plot(obsrich, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed richness', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsrich,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")#
s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")#
s.2011<-subset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")#
SpecRaw<-s.2012#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year="2012" & site!="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Full dataset subsampling script for streamlined sampling analysis#
#Script to create a table with random draws without replacement#
#Roswell 20130528 - Help from James Reilly #
#
# The script uses a homemade function, rline, as well as a package, #
# which must be installed for the script to run properly:#
# Hmisc#
# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#
#include function rline to add reference lines at particular points#
rline<-function(dataname, xcolname, ycolname,indexofrow,...){#
	attach(dataname)#
	#First do the horizontal line#
	segments(x0=-25, y=ycolname[indexofrow], x1=xcolname[indexofrow], #
		y1=ycolname[indexofrow])#
	yval<-format(ycolname[indexofrow], dig=2)#
	mtext(text=yval, side = 2, line = 0, outer = FALSE, at = yval, las=2,#
      cex = 0.5, col = 'red')#
	#Then vertical#
	xval<-format(xcolname[indexofrow], dig=2)#
	segments(x0=xcolname[indexofrow], y=-5, x1=xcolname[indexofrow], #
		y1=ycolname[indexofrow])#
	mtext(text=xval, side = 1, line = 0, outer = FALSE, at = xval, #
    	cex = 0.5, col = 'red')#
	detach(dataname)#
	}#
#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#
#next column represents number of 2.5 min sections included in sample#
#4th column is mean abundance from sample #
#next two columns are abundance and richness in specimen data#
#
#create row label counter#
#
0->corlab#
#Add empty df to populate with subsampling outputs#
abuncor<-data.frame()#
#
for(l in 1:128){	#
	for(m in 1:3){#
		0->rlab#
		#Empty array to populate with for loop#
		Rabund<-array(dim=c(12,7))#
		Rabund<-data.frame(Rabund)#
		for(i in levels(pool$site)){#
			for(j in levels(pool$T_C)){#
				#for(k in c(1:4)){#
					rlab<-rlab+1#
					#Create a table of observations from which to draw#
					#ijkl<-pool[which(pool$site==i & pool$T_C==j & pool$round==k),]#
					ijkl<-pool[which(pool$site==i & pool$T_C==j),]#
					#sample l observed abundances from 2.5 minute sections #
					smpl<-sample(ijkl$ntv.sum, size=l, replace=F)#
					#populate array for step in loop#
					Rabund[rlab, 1]<-i#
					Rabund[rlab, 2]<-j#
					Rabund[rlab, 3]<-l#
					Rabund[rlab, 7]<-m#
					Rabund[rlab, 4]<-mean(smpl)#
					#create a limited specimen table of summary specimen results #
					speci<-specimen[which(specimen$site==i & specimen$T_C==j),]#
					Rabund[rlab,5]<-speci$specabund#
					Rabund[rlab,6]<-speci$specrich#
		}} #i sites and j treatments#
		#Create table of correlations for each number of sections for each iteration#
		corlab<-corlab+1#
		abuncor[corlab,1]<-l#
		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]#
		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]#
		}}#m iterations of size l#
#
abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor"))#
#
#Create summary table of abuncor with means and SEs#
stderror<-function(x){#
(sd(x)/sqrt(length(x)))*1.96#
}#
meanSEs<-summaryBy(acor+rcor~sections, data=abuncor, FUN=c(mean, stderror))#
meanSEs$sections<-meanSEs$section*2.5#
 #create panel for plots#
par(mfrow=c(1,2))#
#
#This library should allow me to plot error bars#
library(Hmisc)#
#
with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, acor.mean-acor.stderror,#
	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #
	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
	pch = 20, type = 'p'))#
abline(h=0.964)#
mtext(text=" 0.96", side = 4, line = 0, outer = FALSE, at = 0.96, las=2,#
	col = 'red')#
#
# rline(meanSEs, sections, acor.mean, 12)#
# rline(meanSEs, sections, acor.mean, 24)	#
# rline(meanSEs, sections, acor.mean, 48)#
with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, #
	rcor.mean-rcor.stderror, #
	title(main=paste("observed abundance and specimen richness \n full dataset", #
		sep="\n")), #
	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
	pch = 20, type = 'p'))#
abline(h=0.855)#
mtext(text=" 0.86", side = 4, line = 0, outer = FALSE, at = 0.86, las=2,#
	col = 'red')#
# rline(meanSEs, sections, rcor.mean, 12)#
# #rline(meanSEs, sections, rcor.mean, 24)	#
# rline(meanSEs, sections, rcor.mean, 48)	#
#
detach(package:Hmisc)
#Full dataset subsampling script for streamlined sampling analysis#
#Script to create a table with random draws without replacement#
#Roswell 20130528 - Help from James Reilly #
#
# The script uses a homemade function, rline, as well as a package, #
# which must be installed for the script to run properly:#
# Hmisc#
# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#
#include function rline to add reference lines at particular points#
rline<-function(dataname, xcolname, ycolname,indexofrow,...){#
	attach(dataname)#
	#First do the horizontal line#
	segments(x0=-25, y=ycolname[indexofrow], x1=xcolname[indexofrow], #
		y1=ycolname[indexofrow])#
	yval<-format(ycolname[indexofrow], dig=2)#
	mtext(text=yval, side = 2, line = 0, outer = FALSE, at = yval, las=2,#
      cex = 0.5, col = 'red')#
	#Then vertical#
	xval<-format(xcolname[indexofrow], dig=2)#
	segments(x0=xcolname[indexofrow], y=-5, x1=xcolname[indexofrow], #
		y1=ycolname[indexofrow])#
	mtext(text=xval, side = 1, line = 0, outer = FALSE, at = xval, #
    	cex = 0.5, col = 'red')#
	detach(dataname)#
	}#
#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#
#next column represents number of 2.5 min sections included in sample#
#4th column is mean abundance from sample #
#next two columns are abundance and richness in specimen data#
#
#create row label counter#
pool<-fpool#
0->corlab#
#Add empty df to populate with subsampling outputs#
abuncor<-data.frame()#
#
for(l in 1:128){	#
	for(m in 1:3){#
		0->rlab#
		#Empty array to populate with for loop#
		Rabund<-array(dim=c(12,7))#
		Rabund<-data.frame(Rabund)#
		for(i in levels(pool$site)){#
			for(j in levels(pool$T_C)){#
				#for(k in c(1:4)){#
					rlab<-rlab+1#
					#Create a table of observations from which to draw#
					#ijkl<-pool[which(pool$site==i & pool$T_C==j & pool$round==k),]#
					ijkl<-pool[which(pool$site==i & pool$T_C==j),]#
					#sample l observed abundances from 2.5 minute sections #
					smpl<-sample(ijkl$ntv.sum, size=l, replace=F)#
					#populate array for step in loop#
					Rabund[rlab, 1]<-i#
					Rabund[rlab, 2]<-j#
					Rabund[rlab, 3]<-l#
					Rabund[rlab, 7]<-m#
					Rabund[rlab, 4]<-mean(smpl)#
					#create a limited specimen table of summary specimen results #
					speci<-specimen[which(specimen$site==i & specimen$T_C==j),]#
					Rabund[rlab,5]<-speci$specabund#
					Rabund[rlab,6]<-speci$specrich#
		}} #i sites and j treatments#
		#Create table of correlations for each number of sections for each iteration#
		corlab<-corlab+1#
		abuncor[corlab,1]<-l#
		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]#
		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]#
		}}#m iterations of size l#
#
abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor"))#
#
#Create summary table of abuncor with means and SEs#
stderror<-function(x){#
(sd(x)/sqrt(length(x)))*1.96#
}#
meanSEs<-summaryBy(acor+rcor~sections, data=abuncor, FUN=c(mean, stderror))#
meanSEs$sections<-meanSEs$section*2.5#
 #create panel for plots#
par(mfrow=c(1,2))#
#
#This library should allow me to plot error bars#
library(Hmisc)#
#
with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, acor.mean-acor.stderror,#
	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #
	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
	pch = 20, type = 'p'))#
abline(h=0.964)#
mtext(text=" 0.96", side = 4, line = 0, outer = FALSE, at = 0.96, las=2,#
	col = 'red')#
#
# rline(meanSEs, sections, acor.mean, 12)#
# rline(meanSEs, sections, acor.mean, 24)	#
# rline(meanSEs, sections, acor.mean, 48)#
with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, #
	rcor.mean-rcor.stderror, #
	title(main=paste("observed abundance and specimen richness \n full dataset", #
		sep="\n")), #
	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
	pch = 20, type = 'p'))#
abline(h=0.855)#
mtext(text=" 0.86", side = 4, line = 0, outer = FALSE, at = 0.86, las=2,#
	col = 'red')#
# rline(meanSEs, sections, rcor.mean, 12)#
# #rline(meanSEs, sections, rcor.mean, 24)	#
# rline(meanSEs, sections, rcor.mean, 48)	#
#
detach(package:Hmisc)
#Full dataset subsampling script for streamlined sampling analysis#
#Script to create a table with random draws without replacement#
#Roswell 20130528 - Help from James Reilly #
#
# The script uses a homemade function, rline, as well as a package, #
# which must be installed for the script to run properly:#
# Hmisc#
# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#
#
#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#
#next column represents number of 2.5 min sections included in sample#
#4th column is mean abundance from sample #
#next two columns are abundance and richness in specimen data#
#
#create row label counter#
pool <- fpool #fpool is the full pool of sites, rounds etc. This allows you to subset and then after subsetting, return to the full pool to try another subset again. #
#
#pool <-subset(pool, round==2|round==4)#
#pool#
0->corlab#
#Add empty df to populate with subsampling outputs#
abuncor<-data.frame()#
specimen$Site <-as.factor(specimen$Site)#
# l is number of observations to include in sample#
for(l in 1:30){	#
# m is number of iterations, and larger numbers will slow down script#
	for(m in 1:128){#
		0->rlab#
		#Empty array to populate with for loop#
		Rabund<-array(dim=c(2*length(unique(pool$Site))),7)#
		Rabund<-data.frame(Rabund)#
	# i is an index for the site#
		for(i in levels(pool$Site)){#
	# j is index for treatment#
			for(j in levels(pool$treatment)){#
				#for(k in c(1:4)){#
					rlab<-rlab+1#
					#Create a table of observations from which to draw#
					#ijkl<-pool[which(pool$site==i & pool$treatment==j & pool$round==k),]#
					ijkl<-pool[which(pool$Site==i & pool$treatment==j),]#
					#sample l observed abundances from 2.5 minute sections #
					smpl<-sample(ijkl$ntv.sum, size=l, replace=F)#
					#populate array for step in loop#
					# first column is site#
					Rabund[rlab, 1]<-i#
					# Second column is treatment#
					Rabund[rlab, 2]<-j#
					#third column is size of sample#
					Rabund[rlab, 3]<-l#
					# fourth column is the mean value for the observations sampled#
					Rabund[rlab, 4]<-mean(smpl)#
						#create a limited specimen table of summary specimen results #
						speci<-specimen[which(specimen$Site==i & specimen$treatment==j),]#
					#fifth column is native bee abundance from the specimen data#
					Rabund[rlab,5]<-speci$specabund#
					#sixth column is native bee richness from spec data#
					Rabund[rlab,6]<-speci$specrich#
					Rabund[rlab, 7]<-m#
		}}#
		#Create table of correlations for each number of sections for each iteration#
		corlab<-corlab+1#
		abuncor[corlab,1]<-l#
		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]#
		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]#
		}}#
#
abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor"))#
###CONSIDER USING QUANTILES RATHER THAN SE #
#Create summary table of abuncor with means and SEs#
stderror<-function(x){#
(sd(x)/sqrt(length(x)))*1.96#
}#
meanSEs<-summaryBy(acor+rcor~sections, data=abuncor, FUN=c(mean, stderror))#
meanSEs$sections<-meanSEs$section*2.5#
#create panel for plots#
#par(mfrow=c(1,2))#
#
#This library should allow me to plot error bars#
library(Hmisc)#
#
#GENERATE PLOTS#
#quartz()#
#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#
#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #
#	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
#	pch = 20, type = 'p'))#
#abline(h=0.964)#
#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#
#	col = 'red')#
#
quartz()#
with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, #
	rcor.mean-rcor.stderror, #
	title(main=paste("MI 2011 observed abundance and specimen richness \n full dataset", #
		sep="\n")), #
	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
	pch = 20, type = 'p'))#
abline(h=0.80)#
mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#
	col = 'red')#
#
detach(package:Hmisc)
speci
pool
Rabund
pool$Site
Specimen
specimen
ObsRaw
str(ObsRaw)
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #
#
#This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#
#it reads in data from all regions from SQL server at Rutgers, and creates summary #
#tables, computing abundance and species richness#
#
#The script also uses R packages you'll need to install. Additionally, I use #
#the package Hmisc in the subsampling script. #
#
#If you don't want to install the packages into your R framework on your computer,#
#the command below should work whether you have them or not already, and install them#
#in some temporary folder to allow this script to run. Just uncomment to run#
#
#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#
#
#these libraries allow creation of abundance and richness vectors, summary tables #
library(plyr)#
library(doBy)#
library(reshape)#
#
#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#
#to compute richness. In our dataset, these are unique, with the exception of "sp", which #
# we are not counting in the richness metric. The summary table created below counts #
#UNIQUE values, so misspellings will count as separate species, whereas species where two#
#bees of different genus share a species name will be counted as one.#
#
#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQL#
library(RMySQL)#
# Access the "R_Winfree_masters" database#
conn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",#
                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")#
# List the tables in the database#
dbListTables(conn)#
#
SpecRaw_MI = dbReadTable(conn, "MI_specimens")#
flr_MI <-dbReadTable(conn, "MI_flowers")#
ObsRaw_MI <-dbReadTable(conn, "MI_observations")#
SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")#
flr_NJ <-dbReadTable(conn, "NJ_flowers")#
ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")#
SpecRaw_CA = dbReadTable(conn, "CA_specimens")#
flr_CA <-dbReadTable(conn, "CA_flowers")#
ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:#
dbListConnections(MySQL())#
#
# disconnect this connection from server:#
dbDisconnect(conn)#
#
# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause grief#
#
cons = dbListConnections(MySQL())#
for(con in cons) {#
  dbDisconnect(con)#
}#
#
## Uncomment below to subset by year#
#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")#
#
## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bind#
flr <- flr_NJ#
#ObsRaw <- ObsRaw_NJ#
#SpecRaw <- SpecRaw_NJ#
#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#
#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#
#flr <- subset(flr_MI, year =="2013")#
#ObsRaw <- ObsRaw_CA#
#str(ObsRaw$csm_group)#
str(SpecRaw)#
#
s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")#
s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")#
s.2011<-subset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")#
SpecRaw<-s.2012#
#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")#
ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site!="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#
#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#
#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#
#flr <- subset(flr_NJ, year=="2012" & site !="MO")#
#
str(ObsRaw)#
#####################################################
#####################################################
### Change chr to factorsy####
#####################################################
#####################################################
flr$uniqueID <-as.factor(flr$uniqueID)#
flr$year <-as.factor(flr$year)#
flr$site <-as.factor(flr$site)#
flr$fdate <-as.factor(flr$fdate)#
flr$round <-as.factor(flr$round)#
flr$treatment <-as.factor(flr$treatment)#
flr$transect <-as.factor(flr$transect)#
flr$quadrat <-as.factor(flr$quadrat)#
flr$plant_genus <-as.factor(flr$plant_genus)#
flr$plant_species <-as.factor(flr$plant_species)#
#str(flr)#
#
ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)#
ObsRaw$year<-as.factor(ObsRaw$year)#
ObsRaw$site<-as.factor(ObsRaw$site)#
ObsRaw$round<-as.factor(ObsRaw$round)#
ObsRaw$transect<-as.factor(ObsRaw$transect)#
ObsRaw$section<-as.factor(ObsRaw$section)#
ObsRaw$treatment<-as.factor(ObsRaw$treatment)#
ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)#
ObsRaw$taxa <-as.factor(ObsRaw$taxa)#
ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#
#str(ObsRaw)#
levels(ObsRaw$csm_group)#
SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)#
SpecRaw$year<-as.factor(SpecRaw$year)#
SpecRaw$site<-as.factor(SpecRaw$site)#
SpecRaw$round<-as.factor(SpecRaw$round)#
SpecRaw$fdate<-as.factor(SpecRaw$fdate)#
SpecRaw$transect<-as.factor(SpecRaw$transect)#
SpecRaw$treatment<-as.factor(SpecRaw$treatment)#
SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)#
SpecRaw$Genus <-as.factor(SpecRaw$Genus)#
SpecRaw$species <-as.factor(SpecRaw$species)#
SpecRaw$basicID <-as.factor(SpecRaw$basicID)#
#str(SpecRaw)#
#####################################################
#####################################################
#####################################################
#####################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sites#
SpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]#
SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#
#
#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#
#summaryBy to create new table with abundance vector. Additional factors (round, #
#transect...) can be added with + after tilde.#
summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#
#summary table with richnesses, called rich#
#used ddply from plyr to get length of unique values #
## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", #
## otherwise it will underestimate richness for some sites #
rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#
#combine into one table that now has total richness and abundance per site #
#(treatment and controls treated as independent)#
cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombus <- total)#
# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #
#
#Create a native bee abundance column#
ObsRaw <- within(ObsRaw, ntv <- total)#
ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon column#
ObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)#
ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA #
#
# #create a green bee abundance column#
# ObsRaw <- within(ObsRaw, green <- total)#
# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 #
#
# #create a green bee+Bombus abundance column#
# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)#
# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #
#
#data cleanup#
#
ObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#
#
#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]#
ObsRaw = droplevels(ObsRaw)#
str(ObsRaw)#
#For anything that doesn't require a function for unique values, I've used summaryBy, #
#and ddply only for the richness#
# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSum#
summaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#
#compute observation "richness" from csm categories#
ddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobs#
observed<-cbind(ObsSum, richobs$N)#
#
#combine to single table#
#
library(reshape)#
#make sure order is same in both tables#
specimen <-specimen[order(specimen$Site, specimen$treatment),]#
observed<-observed[order(observed$Site, observed$treatment),]#
#rename variables#
observed<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))#
#
richabund<-cbind(observed, specimen$specrich, specimen$specabund)#
richabund<-rename(richabund, c("specimen$specrich"="specrich", #
	"specimen$specabund"="specabund"))#
specimen$specrich=as.integer(specimen$specrich)#
#
#same thing again, but with round- there's undoubtedly a more elegant way to do this.#
#this combines the specimen data (where all rounds are combined) with observation data#
#for each round#
# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround#
# summaryBy(ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround#
# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround#
# observedround<-cbind(Obsround, richobsround$N)#
# #
# rbind(specimen, specimen, specimen, specimen)->specimenround#
#
#make sure order is same in both tables#
# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]#
# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]#
# #rename variables#
# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", #
# 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))#
# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))#
# #
# richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)#
# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", #
# 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONS#
fpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, #
	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))#
names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")#
fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count data#
#
flr$f_number<-as.integer(flr$f_number)#
#flr<-flr[which(flr$year != 2011),]#
flr = droplevels(flr)#
flr$Site<-paste(flr$site,flr$year)#
flr$Site<-as.factor(flr$Site)#
###for correlation without simulation#
# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))#
flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#
#
#For richness (which sucks)#
#
flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))#
#
# for the mean quadrat richness#
flrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))#
BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#
#
#most steps beyond this line are just to make a row index that allows simulation to run#
slctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))#
slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#
#
#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.#
names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		#
BS$qnew<-as.factor(BS$qnew)#
names(slctbl)=c("round", "transect", "quadrat", "slct")#
#
#deal with quadrats lacking any flowers#
BS[BS == 0] <- NA#
observed#
specimen#
#
cor.test(flrabu$N, richabund$specrich, method="pearson")#
cor.test(flrric$N, richabund$specrich, method="pearson")#
cor.test(flrabu$N, richabund$specabund, method="pearson")#
cor.test(flrric$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Full dataset subsampling script for streamlined sampling analysis#
#Script to create a table with random draws without replacement#
#Roswell 20130528 - Help from James Reilly #
#
# The script uses a homemade function, rline, as well as a package, #
# which must be installed for the script to run properly:#
# Hmisc#
# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#
#
#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#
#next column represents number of 2.5 min sections included in sample#
#4th column is mean abundance from sample #
#next two columns are abundance and richness in specimen data#
#
#create row label counter#
pool <- fpool #fpool is the full pool of sites, rounds etc. This allows you to subset and then after subsetting, return to the full pool to try another subset again. #
#
#pool <-subset(pool, round==2|round==4)#
#pool#
0->corlab#
#Add empty df to populate with subsampling outputs#
abuncor<-data.frame()#
specimen$Site <-as.factor(specimen$Site)#
# l is number of observations to include in sample#
for(l in 1:30){	#
# m is number of iterations, and larger numbers will slow down script#
	for(m in 1:128){#
		0->rlab#
		#Empty array to populate with for loop#
		Rabund<-array(dim=c(2*length(unique(pool$Site))),7)#
		Rabund<-data.frame(Rabund)#
	# i is an index for the site#
		for(i in levels(pool$Site)){#
	# j is index for treatment#
			for(j in levels(pool$treatment)){#
				#for(k in c(1:4)){#
					rlab<-rlab+1#
					#Create a table of observations from which to draw#
					#ijkl<-pool[which(pool$site==i & pool$treatment==j & pool$round==k),]#
					ijkl<-pool[which(pool$Site==i & pool$treatment==j),]#
					#sample l observed abundances from 2.5 minute sections #
					smpl<-sample(ijkl$ntv.sum, size=l, replace=F)#
					#populate array for step in loop#
					# first column is site#
					Rabund[rlab, 1]<-i#
					# Second column is treatment#
					Rabund[rlab, 2]<-j#
					#third column is size of sample#
					Rabund[rlab, 3]<-l#
					# fourth column is the mean value for the observations sampled#
					Rabund[rlab, 4]<-mean(smpl)#
						#create a limited specimen table of summary specimen results #
						speci<-specimen[which(specimen$Site==i & specimen$treatment==j),]#
					#fifth column is native bee abundance from the specimen data#
					Rabund[rlab,5]<-speci$specabund#
					#sixth column is native bee richness from spec data#
					Rabund[rlab,6]<-speci$specrich#
					Rabund[rlab, 7]<-m#
		}}#
		#Create table of correlations for each number of sections for each iteration#
		corlab<-corlab+1#
		abuncor[corlab,1]<-l#
		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]#
		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]#
		}}#
#
abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor"))#
###CONSIDER USING QUANTILES RATHER THAN SE #
#Create summary table of abuncor with means and SEs#
stderror<-function(x){#
(sd(x)/sqrt(length(x)))*1.96#
}#
meanSEs<-summaryBy(acor+rcor~sections, data=abuncor, FUN=c(mean, stderror))#
meanSEs$sections<-meanSEs$section*2.5#
#create panel for plots#
#par(mfrow=c(1,2))#
#
#This library should allow me to plot error bars#
library(Hmisc)#
#
#GENERATE PLOTS#
#quartz()#
#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#
#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #
#	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
#	pch = 20, type = 'p'))#
#abline(h=0.964)#
#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#
#	col = 'red')#
#
quartz()#
with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, #
	rcor.mean-rcor.stderror, #
	title(main=paste("MI 2011 observed abundance and specimen richness \n full dataset", #
		sep="\n")), #
	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
	pch = 20, type = 'p'))#
abline(h=0.80)#
mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#
	col = 'red')#
#
detach(package:Hmisc)
library(Hmisc)#
#
#GENERATE PLOTS#
#quartz()#
#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#
#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #
#	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
#	pch = 20, type = 'p'))#
#abline(h=0.964)#
#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#
#	col = 'red')#
#
quartz()#
with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, #
	rcor.mean-rcor.stderror, #
	title(main=paste("observed abundance and specimen richness for all NJ sites", #
		sep="\n")), #
	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
	pch = 20, type = 'p'))#
#abline(h=0.80)#
#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#
#	col = 'red')#
#
detach(package:Hmisc)
library(Hmisc)#
#
#GENERATE PLOTS#
#quartz()#
#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#
#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #
#	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
#	pch = 20, type = 'p'))#
#abline(h=0.964)#
#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#
#	col = 'red')#
#
quartz()#
with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, #
	rcor.mean-rcor.stderror, #
	title(main=paste("observed abundance and specimen richness \n for all NJ sites", #
		sep="\n")), #
	xlab=paste("sampling effort \n (minutes)", sep="\n"),#
	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#
	pch = 20, type = 'p'))#
#abline(h=0.80)#
#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#
#	col = 'red')#
#
detach(package:Hmisc)
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, cex=4, lty=4 #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ all years"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
box(lty=4)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')#
#
# #graph 2 (same code as above): observed RICHNESS and specimen richness#
# quartz()#
# with(richabund, plot(obsrich, specrich, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specrich)+15), xlab='observed richness', ylab='specimen richness'))#
# mod1 = lm(specrich~obsrich, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# with(richabund, cor(obsrich,specrich))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 	list(MYVALUE = format(r,dig=3)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 	list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')#
# #
# #graph 3: Observed abundance and specimen abundance#
# quartz()#
# with(richabund, plot(obsabund, specabund, pch = 20, type = 'p', las = 1, #
# 	ylim=c(0,max(specabund)+15), xlab='observed abundance', ylab='specimen abundance'))#
# mod1 = lm(specabund~obsabund, data = richabund)#
# modsum = summary(mod1)#
# abline(modsum)#
# #r2= modsum$adj.r.squared#
# #my.p = modsum$coefficients[2,4]#
# with(richabund, cor(obsabund,specabund))->r#
# #
# #This piece allows arbitrary introduction of expressions into legend#
# slp = modsum$coefficients[2,1]#
# rp = vector('expression',2)#
# rp[1] = substitute(expression(r == MYVALUE), #
# 		list(MYVALUE = format(r,dig=3)))[2]#
# #rp[2] = substitute(expression(italic(p) == MYOTHERVALUE), #
# 		#list(MYOTHERVALUE = format(my.p, digits = 2)))[2]#
# rp[2] = substitute(expression(Slope == MYnextVALUE), #
# 		list(MYnextVALUE = format(slp, dig = 3)))[2]#
# #then, to print it to the graph#
# legend('bottomright', legend=rp, bty='n')
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, cex=4, lty=4, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ all years"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
box(lty=4)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, cex=3, lty=8, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ all years"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
box(lty=4)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')
cor.test(richabund$obsabun,richabund$specrich, method="pearson")#
#
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, cex=3, lwd=4, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ all years"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
box(lwd=4)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')
library(RMySQL)
legend('bottomright', legend=rp, bty='n')
#graph 1: specimen richness by observed abundance#
quartz()#
with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, cex=2, lwd=4, #
	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', #
	main= "Observed abundance and specimen richness, NJ all years"))#
mod1 = lm(specrich~obsabund, data = richabund)#
modsum = summary(mod1)#
box(lwd=4)#
#
#I've just been commenting this out when r is very low. Could also use a logical test:#
# [fake code] if (r>0.3, abline(modsum))#
#
#Note that the following line produces an error message. This is an artefact of using #
#lm as the model with only two variables- only the first two coefficients #
#(slope and intercept) have any meaning#
abline(modsum, lwd=3)#
#
#Below are the tools used before to report r2 and p#
#r2= modsum$adj.r.squared#
#my.p = modsum$coefficients[2,4]#
with(richabund, cor(obsabund,specrich))->r#
#
#This piece allows arbitrary introduction of expressions into legend#
slp = modsum$coefficients[2,1]#
rp = vector('expression',2)#
rp[1] = substitute(expression(r == MYVALUE), #
	list(MYVALUE = format(r,dig=3)))[2]#
rp[2] = substitute(expression(Slope == MYnextVALUE), #
	list(MYnextVALUE = format(slp, dig = 3)))[2]#
#
#then, to print it to the graph#
legend('bottomright', legend=rp, bty='n')
quartz()with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, cex=2, lwd=4, 	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', 	main= "Observed abundance and specimen richness, NJ 2012"))mod1 = lm(specrich~obsabund, data = richabund)modsum = summary(mod1)box(lwd=4)#I've just been commenting this out when r is very low. Could also use a logical test:# [fake code] if (r>0.3, abline(modsum))#Note that the following line produces an error message. This is an artefact of using #lm as the model with only two variables- only the first two coefficients #(slope and intercept) have any meaningabline(modsum, lwd=3)#Below are the tools used before to report r2 and p#r2= modsum$adj.r.squared#my.p = modsum$coefficients[2,4]with(richabund, cor(obsabund,specrich))->r#This piece allows arbitrary introduction of expressions into legendslp = modsum$coefficients[2,1]rp = vector('expression',2)rp[1] = substitute(expression(r == MYVALUE), 	list(MYVALUE = f
ormat(r,dig=3)))[2]rp[2] = substitute(expression(Slope == MYnextVALUE), 	list(MYnextVALUE = format(slp, dig = 3)))[2]#then, to print it to the graphlegend('bottomright', legend=rp, bty='n')
quartz()with(richabund, plot(obsabund, specrich, pch = 20, type = 'p', las = 1, cex=2, lwd=4, 	ylim=c(0,max(specrich)+15), xlab='observed abundance', ylab='specimen richness', 	main= "Observed abundance and specimen richness, NJ 2012"))mod1 = lm(specrich~obsabund, data = richabund)modsum = summary(mod1)box(lwd=4)#I've just been commenting this out when r is very low. Could also use a logical test:# [fake code] if (r>0.3, abline(modsum))#Note that the following line produces an error message. This is an artefact of using #lm as the model with only two variables- only the first two coefficients #(slope and intercept) have any meaningabline(modsum, lwd=3, col="Red")#Below are the tools used before to report r2 and p#r2= modsum$adj.r.squared#my.p = modsum$coefficients[2,4]with(richabund, cor(obsabund,specrich))->r#This piece allows arbitrary introduction of expressions into legendslp = modsum$coefficients[2,1]rp = vector('expression',2)rp[1] = substitute(expression(r == MYVALUE), 	list(
MYVALUE = format(r,dig=3)))[2]rp[2] = substitute(expression(Slope == MYnextVALUE), 	list(MYnextVALUE = format(slp, dig = 3)))[2]#then, to print it to the graphlegend('bottomright', legend=rp, bty='n', col="Red")
library(Hmisc)#GENERATE PLOTS#quartz()#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #	xlab=paste("sampling effort \n (minutes)", sep="\n"),#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#	pch = 20, type = 'p'))#abline(h=0.964)#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#	col = 'red')quartz()with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("observed abundance and specimen richness \n for all NJ sites", 		sep="\n")), 	xlab=paste("sampling effort \n (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=3))#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')
quartz()with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("observed abundance and specimen richness \n for all NJ sites", 		sep="\n")), 	xlab=paste("sampling effort \n (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=1, cex.main=2))#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')
quartz()with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("observed abundance and specimen richness \n for all NJ sites", 		sep="\n")), 	xlab=paste("sampling effort \n (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2))#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')
quartz()with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("observed abundance and specimen richness \n for all NJ sites", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2))
quartz()with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("observed abundance and specimen richness \n for all NJ sites", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 4, 4, 2) + 0.5))
quartz()with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("observed abundance and specimen richness \n for all NJ sites", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))#abline(h=0.80)
quartz()with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("observed abundance and specimen richness \n for all NJ sites", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2)
#Full dataset subsampling script for streamlined sampling analysis#Script to create a table with random draws without replacement#Roswell 20130528 - Help from James Reilly # The script uses a homemade function, rline, as well as a package, # which must be installed for the script to run properly:# Hmisc# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#next column represents number of 2.5 min sections included in sample#4th column is mean abundance from sample #next two columns are abundance and richness in specimen data#create row label counterpool <- fpool #fpool is the full pool of sites, rounds etc. This allows you to subset and then after subsetting, return to the full pool to try another subset again. #pool <-subset(pool, round==2|round==4)#pool0->corlab#Add empty df to populate with subsampling outputsabuncor<-data.frame()specimen$Site <-as.factor(specimen$Site)# l is number of observatio
ns to include in samplefor(l in 1:30){	# m is number of iterations, and larger numbers will slow down script	for(m in 1:128){		0->rlab		#Empty array to populate with for loop		Rabund<-array(dim=c(2*length(unique(pool$Site))),7)		Rabund<-data.frame(Rabund)	# i is an index for the site		for(i in levels(pool$Site)){	# j is index for treatment			for(j in levels(pool$treatment)){				#for(k in c(1:4)){					rlab<-rlab+1#
					#Create a table of observations from which to draw					#ijkl<-pool[which(pool$site==i & pool$treatment==j & pool$round==k),]					ijkl<-pool[which(pool$Site==i & pool$treatment==j),]#
					#sample l observed abundances from 2.5 minute sections 					smpl<-sample(ijkl$ntv.sum, size=l, replace=F)#
					#populate array for step in loop					# first column is site					Rabund[rlab, 1]<-i					# Second column is treatment					Rabund[rlab, 2]<-j					#third column is size of sample					Rabund[rlab, 3]<-l					# fourth column is the mean value for the observations sampled					Rabund[rlab, 4]<-mean(smpl)						#create a limited specimen table of summary specimen results 						speci<-specimen[which(specimen$Site==i & specimen$treatment==j),]					#fifth column is native bee abundance from the specimen data					Rabund[rlab,5]<-speci$specabund					#sixth column is native bee richness from spec data					Rabund[rlab,6]<-speci$specrich#
					Rabund[rlab, 7]<-m		}}		#Create table of correlations for each number of sections for each iteration		corlab<-corlab+1		abuncor[corlab,1]<-l		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]		}}abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor"))#
###CONSIDER USING QUANTILES RATHER THAN SE #Create summary table of abuncor with means and SEsstderror<-function(x){(sd(x)/sqrt(length(x)))*1.96}meanSEs<-summaryBy(acor+rcor~sections, data=abuncor, FUN=c(mean, stderror))meanSEs$sections<-meanSEs$section*2.5#
#create panel for plots#par(mfrow=c(1,2))#This library should allow me to plot error barslibrary(Hmisc)#GENERATE PLOTS#quartz()#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #	xlab=paste("sampling effort \n (minutes)", sep="\n"),#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#	pch = 20, type = 'p'))#abline(h=0.964)#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#	col = 'red')quartz()with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("observed abundance and specimen richness \n for all NJ sites", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2)#abline
(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')detach(package:Hmisc)
library(Hmisc)#GENERATE PLOTS#quartz()#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #	xlab=paste("sampling effort \n (minutes)", sep="\n"),#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#	pch = 20, type = 'p'))#abline(h=0.964)#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#	col = 'red')quartz()with(meanSEs, errbar(sections, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("observed abundance and specimen richness \n for NJ 2012", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')
rm(list=ls())
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#it reads in data from all regions from SQL server at Rutgers, and creates summary #tables, computing abundance and species richness#The script also uses R packages you'll need to install. Additionally, I use #the package Hmisc in the subsampling script. #If you don't want to install the packages into your R framework on your computer,#the command below should work whether you have them or not already, and install them#in some temporary folder to allow this script to run. Just uncomment to run#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#these libraries allow creation of abundance and richness vectors, summary tables library(plyr)library(doBy)library(reshape)#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#to compute richness. In our dataset, the
se are unique, with the exception of "sp", which # we are not counting in the richness metric. The summary table created below counts #UNIQUE values, so misspellings will count as separate species, whereas species where two#bees of different genus share a species name will be counted as one.#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQLlibrary(RMySQL)# Access the "R_Winfree_masters" databaseconn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")# List the tables in the databasedbListTables(conn)SpecRaw_MI = dbReadTable(conn, "MI_specimens")flr_MI <-dbReadTable(conn, "MI_flowers")ObsRaw_MI <-dbReadTable(conn, "MI_observations")SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")flr_NJ <-dbReadTable(conn, "NJ_flowers")ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")SpecRaw_CA = dbReadTable(conn, "CA_specimens")flr_CA <-dbReadTable(conn, "CA_flowers")ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:dbListConnections(MySQL())# disconnect this connection from server:dbDisconnect(conn)# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause griefcons = dbListConnections(MySQL())for(con in cons) {  dbDisconnect(con)}## Uncomment below to subset by year#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bindflr <- flr_NJ#ObsRaw <- ObsRaw_NJ#SpecRaw <- SpecRaw_NJ#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#flr <- subset(flr_MI, year =="2013")#ObsRaw <- ObsRaw_CA#str(ObsRaw$csm_group)str(SpecRaw)s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")s.2011<-s
ubset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")SpecRaw<-rbind(s.2011, s.2012, s.2013)#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")ObsRaw <-subset(ObsRaw_NJ,  site!="MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")str(ObsRaw)########################################################################################################### Change chr to factorsy###########################################################################################################flr$uniqueID <-as.factor(flr$uniqueID)flr$year <-as.factor(flr$year)flr$site <-as.factor(flr$site)flr$fdate <-as.factor(flr$fdate)flr$round <-as.factor(flr$round)
flr$treatment <-as.factor(flr$treatment)flr$transect <-as.factor(flr$transect)flr$quadrat <-as.factor(flr$quadrat)flr$plant_genus <-as.factor(flr$plant_genus)flr$plant_species <-as.factor(flr$plant_species)#str(flr)ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)ObsRaw$year<-as.factor(ObsRaw$year)ObsRaw$site<-as.factor(ObsRaw$site)ObsRaw$round<-as.factor(ObsRaw$round)ObsRaw$transect<-as.factor(ObsRaw$transect)ObsRaw$section<-as.factor(ObsRaw$section)ObsRaw$treatment<-as.factor(ObsRaw$treatment)ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)ObsRaw$taxa <-as.factor(ObsRaw$taxa)ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#str(ObsRaw)levels(ObsRaw$csm_group)SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)SpecRaw$year<-as.factor(SpecRaw$year)SpecRaw$site<-as.factor(SpecRaw$site)SpecRaw$round<-as.factor(SpecRaw$round)SpecRaw$fdate<-as.factor(SpecRaw$fdate)SpecRaw$transect<-as.factor(SpecRaw$transect)SpecRaw$treatment<-as.factor(SpecRaw$treatment)SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)SpecRaw$Genus <-as
.factor(SpecRaw$Genus)SpecRaw$species <-as.factor(SpecRaw$species)SpecRaw$basicID <-as.factor(SpecRaw$basicID)#str(SpecRaw)#################################################################################################################################################################################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sitesSpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#summaryBy to create new table with abundance vector. Additional factors (round, #transect...) can be added with + after tilde.summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#summary table with richnesses, called rich#used ddply from plyr to get length of unique values ## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", ## otherwise it will underestimate richness for some sites rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#combine into one table that now has total richness and abundance per site #(treatment and controls treated as independent)cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column# ObsRaw <- within(ObsRaw, Bombus <- total)# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #Create a native bee abundance columnObsRaw <- within(ObsRaw, ntv <- total)ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon columnObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA # #create a green bee abundance column# ObsRaw <- within(ObsRaw, green <- total)# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 # #create a green bee+Bombus abundance column# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #data cleanupObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]ObsRaw = droplevels(ObsRaw)str(ObsRaw)#For anything that doesn't require a function for unique values, I've used summaryBy, #and ddply only for the richness# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSumsummaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#compute observation "richness" from csm categoriesddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobsob
served<-cbind(ObsSum, richobs$N)#combine to single tablelibrary(reshape)#make sure order is same in both tablesspecimen <-specimen[order(specimen$Site, specimen$treatment),]observed<-observed[order(observed$Site, observed$treatment),]#rename variablesobserved<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))richabund<-cbind(observed, specimen$specrich, specimen$specabund)richabund<-rename(richabund, c("specimen$specrich"="specrich", 	"specimen$specabund"="specabund"))specimen$specrich=as.integer(specimen$specrich)#same thing again, but with round- there's undoubtedly a more elegant way to do this.#this combines the specimen data (where all rounds are combined) with observation data#for each round# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround# summaryBy(
ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround# observedround<-cbind(Obsround, richobsround$N)# # rbind(specimen, specimen, specimen, specimen)->specimenround#make sure order is same in both tables# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]# #rename variables# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", # 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))# # richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", # 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONSfpool = melt(tapply (ObsRaw$ntv, list(ObsRaw$Site, ObsRaw$treatment, ObsRaw$round, 	ObsRaw$section, ObsRaw$am_pm, ObsRaw$transect), sum))names(fpool) = c("Site", "treatment", "round", "section", "am_pm", "transect", "ntv.sum")fpool$ntv.sum[is.na(fpool$ntv.sum)==T] = 0#
# Here, I add the flower count dataflr$f_number<-as.integer(flr$f_number)#flr<-flr[which(flr$year != 2011),]flr = droplevels(flr)flr$Site<-paste(flr$site,flr$year)flr$Site<-as.factor(flr$Site)#
###for correlation without simulation# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#For richness (which sucks)flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))# for the mean quadrat richnessflrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#most steps beyond this line are just to make a row index that allows simulation to runslctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		BS$qnew<-as.factor(BS$qnew)names(slctbl)=c("round", "transect", "quadrat", "slct")#deal with quadrats lacking any flowersBS[BS == 0] <- NAobservedspecimencor.test(flrabu$N, richabund$specrich, method="pearson")cor.test(flrric$N, richabund$specrich, method="pearson")cor.test(flrabu$N, richabund$specabund, method="pearson")cor.test(flrric$N, richabund$specabund, method="pearson")cor.test(flrric2$N, richabund$specabund, method="pearson"
)cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")cor.test(richabund$obsrich,richabund$specrich, method="pearson")
richabund
mean(richabund$specabund)
161/128
161/32
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses j#mult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()mult<-8.91for(j in 1:length(mult)){#set number of iterations nfor(n in 1:50){#j<-1#set number of sitessnum<-12#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-round(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simr
i[which(simri<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated), set here to specimen number 4 rounds*4transects*2times per dayncom<-32#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45#####################################
#################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richness#trans_abundance_mean<-(20*gamma_vect[i]-10)/ncom#trans_abundance<-round(rlnorm(n=ncom, mean=log(trans_abundance_mean)))#### set transect abundance to mean of actual data, about 5trans_abundance<-5## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results
)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance[k], replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[occur_mat>0]<-1       ## calculate the
number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:ncom){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:50){	#Set up some tables and
counters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:50, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
threshtab
Rabund
subsam
j
n
i
j
k
l
m
rsd
simri
results
occurmat
i
gamma_vect[1]
occur
local
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses j#mult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()mult<-8.91for(j in 1:length(mult)){#set number of iterations nfor(n in 1:50){#j<-1#set number of sitessnum<-12#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-round(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simr
i[which(simri<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated), set here to specimen number 4 rounds*4transects*2times per dayncom<-32#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45#####################################
#################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richness#trans_abundance_mean<-(20*gamma_vect[i]-10)/ncom#trans_abundance<-round(rlnorm(n=ncom, mean=log(trans_abundance_mean)))#### set transect abundance to mean of actual data, about 5trans_abundance<-5## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results
)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES   #trans abundance used to be indexed by k           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance, replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat
[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:ncom){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:50){	#Set up some tables and
counters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:50, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
Rabund
x[[1]]
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses j#mult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()mult<-8.91for(j in 1:length(mult)){#set number of iterations nfor(n in 1:50){#j<-1#set number of sitessnum<-12#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-round(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simr
i[which(simri<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated), set here to specimen number 4 rounds*4transects*2times per dayncom<-32#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45#####################################
#################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richness#trans_abundance_mean<-(20*gamma_vect[i]-10)/ncom#trans_abundance<-round(rlnorm(n=ncom, mean=log(trans_abundance_mean)))#### set transect abundance to mean of actual data, about 5trans_abundance<-5## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results
)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES   #trans abundance used to be indexed by k           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance, replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat
[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:ncom){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:50){	#Set up some tables and
counters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:32, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses j#mult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()mult<-8.91for(j in 1:length(mult)){#set number of iterations nfor(n in 1:50){#j<-1#set number of sitessnum<-12#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-round(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simr
i[which(simri<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated), set here to specimen number 4 rounds*4transects*2times per dayncom<-32#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45#####################################
#################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richness#trans_abundance_mean<-(20*gamma_vect[i]-10)/ncom#trans_abundance<-round(rlnorm(n=ncom, mean=log(trans_abundance_mean)))#### set transect abundance to mean of actual data, about 5trans_abundance<-5## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results
)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES   #trans abundance used to be indexed by k           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance, replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat
[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:ncom){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:50){	#Set up some tables and
counters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:32, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
warnings()
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses jmult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()#mult<-8.91for(j in 1:length(mult)){#set number of iterations nfor(n in 1:3){#j<-1#set number of sitessnum<-12#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-round(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simri
[which(simri<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated), set here to specimen number 4 rounds*4transects*2times per dayncom<-32#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45######################################
################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richness#trans_abundance_mean<-(20*gamma_vect[i]-10)/ncom#trans_abundance<-round(rlnorm(n=ncom, mean=log(trans_abundance_mean)))#### set transect abundance to mean of actual data, about 5trans_abundance<-5## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results)
<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES   #trans abundance used to be indexed by k           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance, replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[
occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:ncom){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:50){	#Set up some tables and
counters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:32, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
ANSWER
byrank4
Rabund
i
j
k
m
n
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses j#mult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()mult<-8.91for(j in 1:length(mult)){#set number of iterations nfor(n in 1:3){#j<-1#set number of sitessnum<-12#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-round(rnorm(n=snum, mean=rmean, sd=rsd))#set negative results to 1simri
[which(simri<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated), set here to specimen number 4 rounds*4transects*2times per dayncom<-32#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.45######################################
################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richness#trans_abundance_mean<-(20*gamma_vect[i]-10)/ncom#trans_abundance<-round(rlnorm(n=ncom, mean=log(trans_abundance_mean)))#### set transect abundance to mean of actual data, about 5trans_abundance<-5## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vect[i])->results           dimnames(results)
<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES   #trans abundance used to be indexed by k           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance, replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[
occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:ncom){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:50){	#Set up some tables and
counters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:32, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses jmult<-rnorm(20, mean=8.91, sd=3)#report<-data.frame()#mult<-8.91#Iterate over different SDs of richnessfor(j in 1:length(mult)){#set number of iterations nfor(n in 1:50){#j<-1#set number of sitessnum<-34#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-round(rnorm(n=snum, mean=rmean,
sd=rsd))#set negative results to 1simri[which(simri<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated), set here to specimen number 4 rounds*4transects*2times per dayncom<-32#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specimen data)) setmean<-4.
45######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richnesstrans_abundance_mean<-(20*gamma_vect[i]-10)/ncomtrans_abundance<-round(rlnorm(n=ncom, mean=log(trans_abundance_mean)))#### set transect abundance to mean of actual data, about 5#trans_abundance<-5## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow=ncom,ncol=gamma_vec
t[i])->results           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES   #trans abundance used to be indexed by k           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance, replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->results                } #ends if function       ## convert the abundance-based species by site matrix#into a presence/ absence matrix:
results->occur_mat       occur_mat[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_mat# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i		# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:ncom){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 1:50){	#Set up some tables and
counters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,6))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:32, size=w, replace=F)ba<-x[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,4]-Rabund[,3])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference"))thresh<-1+max(abuncor$transect[which(abuncor$correlations<0.8)])ranks<-1+max(abuncor$transect[which(abuncor$rank_difference>1.6)])counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-threshthreshtab[counter,5] <-ranks} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V5~V3, data=threshtab, FUN=mean)ANSWER<-summaryBy(V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)########################END Subsampling
read.csv("indexing_table.csv", header=t)
#Full dataset subsampling script for streamlined sampling analysis#Script to create a table with random draws without replacement#Roswell 20130528 - Help from James Reilly # The script uses a homemade function, rline, as well as a package, # which must be installed for the script to run properly:# Hmisc# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#next column represents number of 2.5 min sections included in sample#4th column is mean abundance from sample #next two columns are abundance and richness in specimen data#create row label counter#numspec <- fnumspec #fnumspec is the full numspec of sites, rounds etc. This allows you to subset and then after subsetting, return to the full numspec to try another subset again. it<-read.csv("indexing_table.csv", header=T)#numspec <-subset(numspec, round==2|round==4)#numspec0->corlab#Add empty df to populate with subsampling outputsabuncor<-data.frame
()specimen$Site <-as.factor(specimen$Site)SpecRaw$Site <- as.factor(SpecRaw$Site)# l is number of observations to include in samplefor(l in 1:32){	# m is number of iterations, and larger numbers will slow down script	for(m in 1:30){		0->rlab		#Empty array to populate with for loop		Rabund<-array(dim=c(2*length(unique(SpecRaw$Site)),8))		Rabund<-data.frame(Rabund)	# i is an index for the site		for(i in levels(SpecRaw$Site)){	# j is index for treatment			for(j in levels(SpecRaw$treatment)){				#for(k in c(1:4)){					rlab<-rlab+1					subraw<-data.frame()#
					#Create a table of observations from which to draw					#ijkl<-numspec[which(numspec$site==i & numspec$treatment==j & numspec$round==k),]					ijkl<-SpecRaw[which(SpecRaw$Site==i & SpecRaw$treatment==j),]#
					#sample l observed abundances from 2.5 minute sections 					ssindex<-it[sample(1:32, size=l, replace=F),]					for(s in length(ssindex)){						ss<-ssindex[s,]						subraw<-rbind(subraw, ijkl[which(ijkl$round==ss$round & ijkl$transect==						ss$transect & ijkl$am_pm==ss$am_pm),])					}					sr<- length(unique(subraw$species))					sa<-length(subraw$species)					#populate array for step in loop					# first column is site					Rabund[rlab, 1]<-i					# Second column is treatment					Rabund[rlab, 2]<-j					#third column is size of sample					Rabund[rlab, 3]<-l					# fourth column is the mean value for the observations sampled					Rabund[rlab, 4]<-sr					Rabund[rlab, 8]<-sa						#create a limited specimen table of summary specimen results 						speci<-specimen[which(specimen$Site==i & specimen$treatment==j),]					#fifth column is native bee abundance from the specimen data					Rabund[rlab,5]<-speci$specabund					#sixth column is native bee richness from spec data					Rabund[rlab,6]<-speci
$specrich#
					Rabund[rlab, 7]<-m		}}		#Create table of correlations for each number of sections for each iteration		corlab<-corlab+1		abuncor[corlab,1]<-l		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]		abuncor[corlab,4]<-mean(Rabund[,8])		}}abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor", V4="specnum"))#
###CONSIDER USING QUANTILES RATHER THAN SE #Create summary table of abuncor with means and SEsstderror<-function(x){(sd(x)/sqrt(length(x)))*1.96}meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
#create panel for plots#par(mfrow=c(1,2))#This library should allow me to plot error barslibrary(Hmisc)#GENERATE PLOTS#quartz()#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #	xlab=paste("sampling effort \n (minutes)", sep="\n"),#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#	pch = 20, type = 'p'))#abline(h=0.964)#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#	col = 'red')quartz()with(meanSEs, errbar(specnum.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (number of specimens)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2
)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')detach(package:Hmisc)
read.csv("simout.csv")
plot(V3,V6.mean)
simout<-read.csv("simout.csv")
plot(simout$V3,simout$V6.mean)
#############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$### lots or part 1 stolen From Kraft et al. Science 2011##############$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$## R code- PART 1## Simulation to assemble communities at random from## given total abundance, richness, dsitributing individuals among species and among transects##generates output matrices of site- and transect- richness and abundance (both P/A and raw ## abundance forms possible## PART 2 takes these output results and subsamples the transects to and compares how #richness of subsample of## transects predicts richness at the full site (ranking)## PART 3 is a loop over parts 1 and 2 to iterate over a parameter like the SD of richness. #it takes the effort required to reach a correlation of 0.9 ##in the second part (the inner loop), #and generates graphs of how the x-coordinates ## varies with the varaibility over which the #
###################################################### PART 1 ###################################################################library(doBy)library(Hmisc)library(reshape)threshtab<-data.frame()counter<-0#set scale for SD of richnesses jmult<-c(3:23)#report<-data.frame()#mult<-8.91#Iterate over different SDs of richnessfor(j in 1:length(mult)){#set number of iterations nfor(n in 1:10){#j<-1#set number of sitessnum<-34#generate simulated site abundances with mean from specimen, using lognormal#simab<-trunc(rlnorm(n=snum, meanlog=mean(log(specimen$specabund))))######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################generate simulated richnesses with mean, SD from specimen, using a normal distribution#specimen richness mean, SD 18.79, 8.91rmean<-18.79#rsd<-8.91/(1+log(j))rsd<-mult[j]simri<-round(rnorm(n=snum, mean=rmean, sd=rsd))#set nega
tive results to 1, no comma before ] for vectorsimri[which(simri<1)]<-1#this was to visualize the simulated data alongside the observed data# quartz()# hist(simri, breaks=9)# quartz()# hist(specimen$specrich, breaks=12)# quartz()# hist(simab)# quartz()# hist(specimen$specabund)########################### start of simulation ############################# vector of site richnesses, here set to simulated from normal distribution:gamma_vect=simri## transects per site (simulated), set here to specimen number 4 rounds*4transects*2times per dayncom<-32#lots of arrays to set to null before loopgamma_obs<-NULL #reset variables from prior simulationsmeans<-NULL #x<-list()y<-list()vars<-NULL #gamma<-NULL #stems<-NULL #poollike<-data.frame()gamma_obs<-NULL #mean_alpha<-NULL #output<-data.frame()corlab<-0#Add empty df to populate with subsampling outputsabuncor<-data.frame()# i is site idfor(i in 1:snum){##number of individuals/transect generated from a mean, 4.45 is mean(log(specime
n data)) setmean<-4.45######################################################################??????????WHAT DISTRIBUTIONS TO USE????????????????############################################################################# drawn from a with mean log normal, then drawn from another log normal ##for each each transect #trans_abundance_mean<-rlnorm(n=1, mean=setmean)#trans_abundance<-rlnorm(n=50, mean=log(trans_abundance_mean))#try fixing abundance to richnesstrans_abundance_mean<-(20*gamma_vect[i]-10)/ncomtrans_abundance<-round(rlnorm(n=ncom, mean=log(trans_abundance_mean)))#### set transect abundance to mean of actual data, about 5#trans_abundance<-5## Then assign proportions of individuals to which to assign each species identity, ## again drawn from log normaloccur<-rlnorm(n=gamma_vect[i]) # random log normal ~ proportional to probability of individual having a give identity## build an empty species by site matrix to hold the data           matrix(data=rep(0, ncom*gamma_vect[i]), nrow
=ncom,ncol=gamma_vect[i])->results           dimnames(results)<-list(seq(1:ncom),seq(1:gamma_vect[i]))           ## populate each transect (row of matrix) by#sampling individuals with replacement   ## from the species pool; k is index for TRANSECTS, i for SITES   #trans abundance used to be indexed by k           for(k in 1:ncom){               local<-sample(1:gamma_vect[i],size=trans_abundance, replace=TRUE, prob=occur)               table(local)->tab   results[k, unlist(dimnames(results)[2]) %in% names(tab)]<-tab}#ends loop to generate a single "site" community, indexed by k# for a site, a set of transects with species id, richness, and abundance.       ## remove any species from the species by site matrix#that do not occur in any community:       if(sum(apply(results, MARGIN=2, FUN=sum)==0)>0    ){                results[,-(which(apply(results, MARGIN=2,FUN=sum)==0))]->resultsresults<-as.matrix(results)                } #ends if function       ## convert the abundance-based species
by site matrix#into a presence/ absence matrix:       results->occur_mat       occur_mat[occur_mat>0]<-1       ## calculate the number of species present in each transect (alphas):       #alphas<-apply(occur_mat, MARGIN=1, FUN=sum)#
       ##transect abundance      # trab<-apply(results, MARGIN=1, FUN=sum)#
       ## compose matrix with sites i, transects 1:50, alphas and trabs       #poolstart<-cbind(i, alphas, trab)      # poollike<-rbind(poollike, poolstart)       ## richness of sites (all transects combined):       gamma_observed<-ncol(results)       gamma_obs<-c(gamma_obs, gamma_observed) # all the sites       occur_mat<-as.data.frame(occur_mat)x[[i]]<-occur_maty[[i]]<-results# counter<-counter+1 #remove when uncommenting next loop# report[counter,"site"]<-i	# report[counter,"iteration"]<-n# report[counter,"sdinput"]<-j# report[counter,"realizedsd"]<-sd(gamma_obs)} #ends for i (iteration for each site, generating and modifying matrix of transects by species IDs)######################################### Part 2 $################################This sections subsamples the transects from the artificial sites generated above.#w is number of transects to include in a samplefor(w in 1:ncom){	# m is number of iterations, and larger numbers will slow down scriptfor(m in 10){	#Set up so
me tables and counters for subsampling#row label for subsampling0->rlab#Empty array to populate with subsampling for loopRabund<-array(dim=c(snum,7))Rabund<-data.frame(Rabund)	# iterate over i sitesfor(i in 1:snum){rlab<-rlab+1#sample w subsamples (transects) of simulated sites smpl<-sample(1:ncom, size=w, replace=F)ba<-y[[i]]subsam<-ba[smpl,, drop=FALSE]if(sum(apply(subsam, MARGIN=2, FUN=sum)==0)>0    ){                subsam[,-(which(apply(subsam, MARGIN=2,FUN=sum)==0)), drop=F]->subsam                }#
#populate array for step in loop- for each site i for each iteration m# first column is siteRabund[rlab, 1]<-i#second column for size of sample (DPC...Number of Transects correct?)Rabund[rlab, 2]<-w# third column is the richness of site based on sampled transectsRabund[rlab, 3]<-ncol(subsam) #fourth is native bee richness in simulated sites (all transects)Rabund[rlab,4]<-gamma_obs[i]Rabund[rlab,7]<-sum(subsam)} #Ends for i sites, #Create table of correlations for each number of sections for each iterationcorlab<-corlab+1abuncor[corlab,1]<-wRabund[,5]<-rank(Rabund[,3]) #rank based on subsampleRabund[,6]<-rank(Rabund[,4]) #rank based on whole "site"cor(Rabund[,3], Rabund[,4])->abuncor[corlab,2]abuncor[corlab, 3]<- sum(Rabund[,5]-Rabund[,6])abuncor[corlab, 4] <-mean(Rabund[,7])} } #Ends for size w for m iterations#
abuncor<-rename(abuncor, c(V1="transects", V2="correlations", V3="rank_difference", V4="number_samples"))cort<-abuncor[which(abs(abuncor$correlations)>0.8),]thresh<-max(1,min(cort$transects))rankst<-abuncor[which(abs(abuncor$rank_difference)<1),]ranks<-max(1,min(rankst$transects))counter<-counter+1threshtab[counter,1]<-jthreshtab[counter,2]<-mult[j]threshtab[counter,3]<-rsdthreshtab[counter,4]<-max(1,thresh)threshtab[counter,5] <-max(1,ranks)threshtab[counter,6]<-cort[thresh, 4]} #ends for n, or each iteration of the whole loop at an SD level} #ends for jbyrank4<-summaryBy(V6+V5~V3, data=threshtab, FUN=mean)byrank4$V5.mean[which(byrank4$V5.mean<0)]<-1byrank4$V6.mean[which(byrank4$V6.mean=="NA")]<-0ANSWER<-summaryBy(V6+V4~V3, data=threshtab, FUN=mean) #V1 - index for richness, V2- multiplier for SD of richness #V3 - SD of richness, V4 number of transects to reach correlation with full (0.9)ANSWER$V4.mean[which(ANSWER$V4.mean<0)]<-1ANSWER$V6.mean[which(ANSWER$V6.mean==NA)]<-0############
############END Subsampling
ANSWER
byrank4
plot(ANSWER$V3,ANSWER$V5.mean)
plot(ANSWER$V3,ANSWER$V4.mean)
quartz()
plot(ANSWER$V3,ANSWER$V6.mean)
?plyr
?dplyr
plot(ANSWER$V3,ANSWER$V6.mean, cex.axis=2, cex=2, pch=19)
box(lwd=5)
, lwd=5
plot(ANSWER$V3,ANSWER$V6.mean, cex.axis=2, cex=2, pch=19,lwd=5)
box(lwd=5)
plot(ANSWER$V3,ANSWER$V6.mean, cex.axis=2, pch=19,lwd=5)
box(lwd=5)
plot(ANSWER$V3,ANSWER$V4.mean, cex.axis=2, pch=19,lwd=5)
box(lwd=5)
plot(ANSWER$V3,ANSWER$V4.mean*10, cex.axis=2, pch=19,lwd=5)
box(lwd=5)
answertrunc<-ANSWER[which(ANSWER$V3<16)]
answertrunc<-ANSWER[which(ANSWER$V3<16),]
summary(lm(ANSWER$V4.mean, ANSWER$V3))
summary(lm(ANSWER$V4.mean~ANSWER$V3))
answertrunc<-ANSWER[which(ANSWER$V3<17),]
summary(lm(ANSWER$V4.mean~ANSWER$V3))
answertrunc<-ANSWER[which(ANSWER$V3<15),]
summary(lm(ANSWER$V4.mean~ANSWER$V3))
summary(lm(answertrunc$V4.mean~answertrunc$V3))
answertrunc<-ANSWER[which(ANSWER$V3<16),]
summary(lm(answertrunc$V4.mean~answertrunc$V3))
answertrunc<-ANSWER[which(ANSWER$V3<17),]
summary(lm(answertrunc$V4.mean~answertrunc$V3))
answertrunc<-ANSWER[which(1<ANSWER$V3<17),]
answertrunc<-ANSWER[which(ANSWER$V3<17 &ANSWER$V3>1),]
summary(lm(answertrunc$V4.mean~answertrunc$V3))
answertrunc<-ANSWER[which(ANSWER$V3<16 &ANSWER$V3>1),]
summary(lm(answertrunc$V4.mean~answertrunc$V3))
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#it reads in data from all regions from SQL server at Rutgers, and creates summary #tables, computing abundance and species richness#The script also uses R packages you'll need to install. Additionally, I use #the package Hmisc in the subsampling script. #If you don't want to install the packages into your R framework on your computer,#the command below should work whether you have them or not already, and install them#in some temporary folder to allow this script to run. Just uncomment to run#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#these libraries allow creation of abundance and richness vectors, summary tables library(plyr)library(doBy)library(reshape)#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#to compute richness. In our dataset, the
se are unique, with the exception of "sp", which # we are not counting in the richness metric. The summary table created below counts #UNIQUE values, so misspellings will count as separate species, whereas species where two#bees of different genus share a species name will be counted as one.#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQLlibrary(RMySQL)# Access the "R_Winfree_masters" databaseconn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")# List the tables in the databasedbListTables(conn)SpecRaw_MI = dbReadTable(conn, "MI_specimens")flr_MI <-dbReadTable(conn, "MI_flowers")ObsRaw_MI <-dbReadTable(conn, "MI_observations")SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")flr_NJ <-dbReadTable(conn, "NJ_flowers")ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")SpecRaw_CA = dbReadTable(conn, "CA_specimens")flr_CA <-dbReadTable(conn, "CA_flowers")ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:dbListConnections(MySQL())# disconnect this connection from server:dbDisconnect(conn)# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause griefcons = dbListConnections(MySQL())for(con in cons) {  dbDisconnect(con)}## Uncomment below to subset by year#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bindflr <- flr_NJ#ObsRaw <- ObsRaw_NJ#SpecRaw <- SpecRaw_NJ#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#flr <- subset(flr_MI, year =="2013")#ObsRaw <- ObsRaw_CA#str(ObsRaw$csm_group)str(SpecRaw)s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")s.2011<-s
ubset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")SpecRaw<-rbind(s.2012, s.2011, s.2013)#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")ObsRaw <-subset(ObsRaw_NJ,  site != "MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")str(ObsRaw)########################################################################################################### Change chr to factorsy###########################################################################################################flr$uniqueID <-as.factor(flr$uniqueID)flr$year <-as.factor(flr$year)flr$site <-as.factor(flr$site)flr$fdate <-as.factor(flr$fdate)flr$round <-as.factor(flr$roun
d)flr$treatment <-as.factor(flr$treatment)flr$transect <-as.factor(flr$transect)flr$quadrat <-as.factor(flr$quadrat)flr$plant_genus <-as.factor(flr$plant_genus)flr$plant_species <-as.factor(flr$plant_species)#str(flr)ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)ObsRaw$year<-as.factor(ObsRaw$year)ObsRaw$site<-as.factor(ObsRaw$site)ObsRaw$round<-as.factor(ObsRaw$round)ObsRaw$transect<-as.factor(ObsRaw$transect)ObsRaw$section<-as.factor(ObsRaw$section)ObsRaw$treatment<-as.factor(ObsRaw$treatment)ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)ObsRaw$taxa <-as.factor(ObsRaw$taxa)ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#str(ObsRaw)levels(ObsRaw$csm_group)SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)SpecRaw$year<-as.factor(SpecRaw$year)SpecRaw$site<-as.factor(SpecRaw$site)SpecRaw$round<-as.factor(SpecRaw$round)SpecRaw$fdate<-as.factor(SpecRaw$fdate)SpecRaw$transect<-as.factor(SpecRaw$transect)SpecRaw$treatment<-as.factor(SpecRaw$treatment)SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)SpecRaw$Genus <-
as.factor(SpecRaw$Genus)SpecRaw$species <-as.factor(SpecRaw$species)SpecRaw$basicID <-as.factor(SpecRaw$basicID)#str(SpecRaw)#################################################################################################################################################################################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sitesSpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)SpecRaw<-SpecRaw[which(SpecRaw$am_pm=="AM"|SpecRaw$am_pm=="PM"),]#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#summaryBy to create new table with abundance vector. Additional factors (round, #transect...) can be added with + after tilde.summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#summary table with richnesses, called rich#used ddply from plyr to get length of unique values ## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", ## otherwise it will underestimate richness for some sites rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#create a table with number of individuals per transect#numspec<-summaryBy(species ~ Site + site + treatment + transect + round, data=Spec
Raw, FUN=length)SpecRaw<-SpecRaw[which(SpecRaw$basicID == "bee"),]SpecRaw=droplevels(SpecRaw)distinct<-function(x){	length(unique(x))	}rspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), distinct))names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich")rspec$rich[is.na(rspec$rich)==T] = 0numspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), length))names(numspec) = c("Site", "treatment", "round",  "am_pm", "transect", "specnum")numspec$specnum[is.na(numspec$specnum)==T] = 0rspec<-cbind(rspec, numspec$specnum)names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich", "specnum")#combine into one table that now has total richness and abundance per site #(treatment and controls treated as independent)cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column# ObsRaw <- within(ObsRaw, Bombus <- total)# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #Create a native bee abundance columnObsRaw <- within(ObsRaw, ntv <- total)ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon columnObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA # #create a green bee abundance column# ObsRaw <- within(ObsRaw, green <- total)# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 # #create a green bee+Bombus abundance column# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #data cleanupObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]ObsRaw = droplevels(ObsRaw)str(ObsRaw)#For anything that doesn't require a function for unique values, I've used summaryBy, #and ddply only for the richness# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSumsummaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#compute observation "richness" from csm categoriesddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobsob
served<-cbind(ObsSum, richobs$N)#combine to single tablelibrary(reshape)#make sure order is same in both tablesspecimen <-specimen[order(specimen$Site, specimen$treatment),]observed<-observed[order(observed$Site, observed$treatment),]#rename variablesobserved<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))richabund<-cbind(observed, specimen$specrich, specimen$specabund)richabund<-rename(richabund, c("specimen$specrich"="specrich", 	"specimen$specabund"="specabund"))specimen$specrich=as.integer(specimen$specrich)#same thing again, but with round- there's undoubtedly a more elegant way to do this.#this combines the specimen data (where all rounds are combined) with observation data#for each round# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround# summaryBy(
ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround# observedround<-cbind(Obsround, richobsround$N)# # rbind(specimen, specimen, specimen, specimen)->specimenround#make sure order is same in both tables# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]# #rename variables# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", # 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))# # richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", # 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONSspool = melt(tapply (SpecRaw$uniqueID, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, SpecRaw$am_pm, SpecRaw$transect, SpecRaw$species), length))names(spool) = c("Site", "treatment", "round", "am_pm", "transect", "species", "slength")spool$slength[is.na(spool$slength)==T] = 0#
# Here, I add the flower count dataflr$f_number<-as.integer(flr$f_number)#flr<-flr[which(flr$year != 2011),]flr = droplevels(flr)flr$Site<-paste(flr$site,flr$year)flr$Site<-as.factor(flr$Site)#
###for correlation without simulation# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#For richness (which sucks)flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))# for the mean quadrat richnessflrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#most steps beyond this line are just to make a row index that allows simulation to runslctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		BS$qnew<-as.factor(BS$qnew)names(slctbl)=c("round", "transect", "quadrat", "slct")#deal with quadrats lacking any flowersBS[BS == 0] <- NAobservedspecimencor.test(flrabu$N, richabund$specrich, method="pearson")cor.test(flrric$N, richabund$specrich, method="pearson")cor.test(flrabu$N, richabund$specabund, method="pearson")cor.test(flrric$N, richabund$specabund, method="pearson")cor.test(flrric2$N, richabund$specabund, method="pearson"
)cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")cor.test(richabund$obsrich,richabund$specrich, method="pearson")
specimen
var(specimen$specrich)
summary(specimen$specrich)
sd(specimen$specrich)
mean(specimen$specrich)
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#it reads in data from all regions from SQL server at Rutgers, and creates summary #tables, computing abundance and species richness#The script also uses R packages you'll need to install. Additionally, I use #the package Hmisc in the subsampling script. #If you don't want to install the packages into your R framework on your computer,#the command below should work whether you have them or not already, and install them#in some temporary folder to allow this script to run. Just uncomment to run#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#these libraries allow creation of abundance and richness vectors, summary tables library(plyr)library(doBy)library(reshape)#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#to compute richness. In our dataset, the
se are unique, with the exception of "sp", which # we are not counting in the richness metric. The summary table created below counts #UNIQUE values, so misspellings will count as separate species, whereas species where two#bees of different genus share a species name will be counted as one.#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQLlibrary(RMySQL)# Access the "R_Winfree_masters" databaseconn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")# List the tables in the databasedbListTables(conn)SpecRaw_MI = dbReadTable(conn, "MI_specimens")flr_MI <-dbReadTable(conn, "MI_flowers")ObsRaw_MI <-dbReadTable(conn, "MI_observations")SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")flr_NJ <-dbReadTable(conn, "NJ_flowers")ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")SpecRaw_CA = dbReadTable(conn, "CA_specimens")flr_CA <-dbReadTable(conn, "CA_flowers")ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:dbListConnections(MySQL())# disconnect this connection from server:dbDisconnect(conn)# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause griefcons = dbListConnections(MySQL())for(con in cons) {  dbDisconnect(con)}## Uncomment below to subset by year#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bindflr <- flr_NJ#ObsRaw <- ObsRaw_NJ#SpecRaw <- SpecRaw_NJ#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#flr <- subset(flr_MI, year =="2013")#ObsRaw <- ObsRaw_CA#str(ObsRaw$csm_group)str(SpecRaw)s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")s.2011<-s
ubset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")SpecRaw<-rbind(s.2012)#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")ObsRaw <-subset(ObsRaw_NJ,  site != "MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")str(ObsRaw)########################################################################################################### Change chr to factorsy###########################################################################################################flr$uniqueID <-as.factor(flr$uniqueID)flr$year <-as.factor(flr$year)flr$site <-as.factor(flr$site)flr$fdate <-as.factor(flr$fdate)flr$round <-as.factor(flr$round)flr$treatment
<-as.factor(flr$treatment)flr$transect <-as.factor(flr$transect)flr$quadrat <-as.factor(flr$quadrat)flr$plant_genus <-as.factor(flr$plant_genus)flr$plant_species <-as.factor(flr$plant_species)#str(flr)ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)ObsRaw$year<-as.factor(ObsRaw$year)ObsRaw$site<-as.factor(ObsRaw$site)ObsRaw$round<-as.factor(ObsRaw$round)ObsRaw$transect<-as.factor(ObsRaw$transect)ObsRaw$section<-as.factor(ObsRaw$section)ObsRaw$treatment<-as.factor(ObsRaw$treatment)ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)ObsRaw$taxa <-as.factor(ObsRaw$taxa)ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#str(ObsRaw)levels(ObsRaw$csm_group)SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)SpecRaw$year<-as.factor(SpecRaw$year)SpecRaw$site<-as.factor(SpecRaw$site)SpecRaw$round<-as.factor(SpecRaw$round)SpecRaw$fdate<-as.factor(SpecRaw$fdate)SpecRaw$transect<-as.factor(SpecRaw$transect)SpecRaw$treatment<-as.factor(SpecRaw$treatment)SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)SpecRaw$Genus <-as.factor(SpecRa
w$Genus)SpecRaw$species <-as.factor(SpecRaw$species)SpecRaw$basicID <-as.factor(SpecRaw$basicID)#str(SpecRaw)#################################################################################################################################################################################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sitesSpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)SpecRaw<-SpecRaw[which(SpecRaw$am_pm=="AM"|SpecRaw$am_pm=="PM"),]#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#summaryBy to create new table with abundance vector. Additional factors (round, #transect...) can be added with + after tilde.summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#summary table with richnesses, called rich#used ddply from plyr to get length of unique values ## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", ## otherwise it will underestimate richness for some sites rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#create a table with number of individuals per transect#numspec<-summaryBy(species ~ Site + site + treatment + transect + round, data=Spec
Raw, FUN=length)SpecRaw<-SpecRaw[which(SpecRaw$basicID == "bee"),]SpecRaw=droplevels(SpecRaw)distinct<-function(x){	length(unique(x))	}rspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), distinct))names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich")rspec$rich[is.na(rspec$rich)==T] = 0numspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), length))names(numspec) = c("Site", "treatment", "round",  "am_pm", "transect", "specnum")numspec$specnum[is.na(numspec$specnum)==T] = 0rspec<-cbind(rspec, numspec$specnum)names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich", "specnum")#combine into one table that now has total richness and abundance per site #(treatment and controls treated as independent)cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column# ObsRaw <- within(ObsRaw, Bombus <- total)# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #Create a native bee abundance columnObsRaw <- within(ObsRaw, ntv <- total)ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon columnObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA # #create a green bee abundance column# ObsRaw <- within(ObsRaw, green <- total)# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 # #create a green bee+Bombus abundance column# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #data cleanupObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]ObsRaw = droplevels(ObsRaw)str(ObsRaw)#For anything that doesn't require a function for unique values, I've used summaryBy, #and ddply only for the richness# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSumsummaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#compute observation "richness" from csm categoriesddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobsob
served<-cbind(ObsSum, richobs$N)#combine to single tablelibrary(reshape)#make sure order is same in both tablesspecimen <-specimen[order(specimen$Site, specimen$treatment),]observed<-observed[order(observed$Site, observed$treatment),]#rename variablesobserved<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))richabund<-cbind(observed, specimen$specrich, specimen$specabund)richabund<-rename(richabund, c("specimen$specrich"="specrich", 	"specimen$specabund"="specabund"))specimen$specrich=as.integer(specimen$specrich)#same thing again, but with round- there's undoubtedly a more elegant way to do this.#this combines the specimen data (where all rounds are combined) with observation data#for each round# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround# summaryBy(
ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround# observedround<-cbind(Obsround, richobsround$N)# # rbind(specimen, specimen, specimen, specimen)->specimenround#make sure order is same in both tables# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]# #rename variables# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", # 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))# # richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", # 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONSspool = melt(tapply (SpecRaw$uniqueID, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, SpecRaw$am_pm, SpecRaw$transect, SpecRaw$species), length))names(spool) = c("Site", "treatment", "round", "am_pm", "transect", "species", "slength")spool$slength[is.na(spool$slength)==T] = 0#
# Here, I add the flower count dataflr$f_number<-as.integer(flr$f_number)#flr<-flr[which(flr$year != 2011),]flr = droplevels(flr)flr$Site<-paste(flr$site,flr$year)flr$Site<-as.factor(flr$Site)#
###for correlation without simulation# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#For richness (which sucks)flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))# for the mean quadrat richnessflrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#most steps beyond this line are just to make a row index that allows simulation to runslctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		BS$qnew<-as.factor(BS$qnew)names(slctbl)=c("round", "transect", "quadrat", "slct")#deal with quadrats lacking any flowersBS[BS == 0] <- NAobservedspecimencor.test(flrabu$N, richabund$specrich, method="pearson")cor.test(flrric$N, richabund$specrich, method="pearson")cor.test(flrabu$N, richabund$specabund, method="pearson")cor.test(flrric$N, richabund$specabund, method="pearson")cor.test(flrric2$N, richabund$specabund, method="pearson"
)cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")cor.test(richabund$obsrich,richabund$specrich, method="pearson")
sd(specimen$specrich)
mean(specimen$specrich)
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#it reads in data from all regions from SQL server at Rutgers, and creates summary #tables, computing abundance and species richness#The script also uses R packages you'll need to install. Additionally, I use #the package Hmisc in the subsampling script. #If you don't want to install the packages into your R framework on your computer,#the command below should work whether you have them or not already, and install them#in some temporary folder to allow this script to run. Just uncomment to run#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#these libraries allow creation of abundance and richness vectors, summary tables library(plyr)library(doBy)library(reshape)#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#to compute richness. In our dataset, the
se are unique, with the exception of "sp", which # we are not counting in the richness metric. The summary table created below counts #UNIQUE values, so misspellings will count as separate species, whereas species where two#bees of different genus share a species name will be counted as one.#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQLlibrary(RMySQL)# Access the "R_Winfree_masters" databaseconn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")# List the tables in the databasedbListTables(conn)SpecRaw_MI = dbReadTable(conn, "MI_specimens")flr_MI <-dbReadTable(conn, "MI_flowers")ObsRaw_MI <-dbReadTable(conn, "MI_observations")SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")flr_NJ <-dbReadTable(conn, "NJ_flowers")ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")SpecRaw_CA = dbReadTable(conn, "CA_specimens")flr_CA <-dbReadTable(conn, "CA_flowers")ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:dbListConnections(MySQL())# disconnect this connection from server:dbDisconnect(conn)# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause griefcons = dbListConnections(MySQL())for(con in cons) {  dbDisconnect(con)}## Uncomment below to subset by year#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bindflr <- flr_NJ#ObsRaw <- ObsRaw_NJ#SpecRaw <- SpecRaw_NJ#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#flr <- subset(flr_MI, year =="2013")#ObsRaw <- ObsRaw_CA#str(ObsRaw$csm_group)str(SpecRaw)s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")s.2011<-s
ubset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")SpecRaw<-rbind(s.2011)#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")ObsRaw <-subset(ObsRaw_NJ,  site != "MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")str(ObsRaw)########################################################################################################### Change chr to factorsy###########################################################################################################flr$uniqueID <-as.factor(flr$uniqueID)flr$year <-as.factor(flr$year)flr$site <-as.factor(flr$site)flr$fdate <-as.factor(flr$fdate)flr$round <-as.factor(flr$round)flr$treatment
<-as.factor(flr$treatment)flr$transect <-as.factor(flr$transect)flr$quadrat <-as.factor(flr$quadrat)flr$plant_genus <-as.factor(flr$plant_genus)flr$plant_species <-as.factor(flr$plant_species)#str(flr)ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)ObsRaw$year<-as.factor(ObsRaw$year)ObsRaw$site<-as.factor(ObsRaw$site)ObsRaw$round<-as.factor(ObsRaw$round)ObsRaw$transect<-as.factor(ObsRaw$transect)ObsRaw$section<-as.factor(ObsRaw$section)ObsRaw$treatment<-as.factor(ObsRaw$treatment)ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)ObsRaw$taxa <-as.factor(ObsRaw$taxa)ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#str(ObsRaw)levels(ObsRaw$csm_group)SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)SpecRaw$year<-as.factor(SpecRaw$year)SpecRaw$site<-as.factor(SpecRaw$site)SpecRaw$round<-as.factor(SpecRaw$round)SpecRaw$fdate<-as.factor(SpecRaw$fdate)SpecRaw$transect<-as.factor(SpecRaw$transect)SpecRaw$treatment<-as.factor(SpecRaw$treatment)SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)SpecRaw$Genus <-as.factor(SpecRa
w$Genus)SpecRaw$species <-as.factor(SpecRaw$species)SpecRaw$basicID <-as.factor(SpecRaw$basicID)#str(SpecRaw)#################################################################################################################################################################################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sitesSpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)SpecRaw<-SpecRaw[which(SpecRaw$am_pm=="AM"|SpecRaw$am_pm=="PM"),]#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#summaryBy to create new table with abundance vector. Additional factors (round, #transect...) can be added with + after tilde.summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#summary table with richnesses, called rich#used ddply from plyr to get length of unique values ## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", ## otherwise it will underestimate richness for some sites rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#create a table with number of individuals per transect#numspec<-summaryBy(species ~ Site + site + treatment + transect + round, data=Spec
Raw, FUN=length)SpecRaw<-SpecRaw[which(SpecRaw$basicID == "bee"),]SpecRaw=droplevels(SpecRaw)distinct<-function(x){	length(unique(x))	}rspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), distinct))names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich")rspec$rich[is.na(rspec$rich)==T] = 0numspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), length))names(numspec) = c("Site", "treatment", "round",  "am_pm", "transect", "specnum")numspec$specnum[is.na(numspec$specnum)==T] = 0rspec<-cbind(rspec, numspec$specnum)names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich", "specnum")#combine into one table that now has total richness and abundance per site #(treatment and controls treated as independent)cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column# ObsRaw <- within(ObsRaw, Bombus <- total)# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #Create a native bee abundance columnObsRaw <- within(ObsRaw, ntv <- total)ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon columnObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA # #create a green bee abundance column# ObsRaw <- within(ObsRaw, green <- total)# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 # #create a green bee+Bombus abundance column# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #data cleanupObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]ObsRaw = droplevels(ObsRaw)str(ObsRaw)#For anything that doesn't require a function for unique values, I've used summaryBy, #and ddply only for the richness# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSumsummaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#compute observation "richness" from csm categoriesddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobsob
served<-cbind(ObsSum, richobs$N)#combine to single tablelibrary(reshape)#make sure order is same in both tablesspecimen <-specimen[order(specimen$Site, specimen$treatment),]observed<-observed[order(observed$Site, observed$treatment),]#rename variablesobserved<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))richabund<-cbind(observed, specimen$specrich, specimen$specabund)richabund<-rename(richabund, c("specimen$specrich"="specrich", 	"specimen$specabund"="specabund"))specimen$specrich=as.integer(specimen$specrich)#same thing again, but with round- there's undoubtedly a more elegant way to do this.#this combines the specimen data (where all rounds are combined) with observation data#for each round# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround# summaryBy(
ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround# observedround<-cbind(Obsround, richobsround$N)# # rbind(specimen, specimen, specimen, specimen)->specimenround#make sure order is same in both tables# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]# #rename variables# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", # 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))# # richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", # 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONSspool = melt(tapply (SpecRaw$uniqueID, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, SpecRaw$am_pm, SpecRaw$transect, SpecRaw$species), length))names(spool) = c("Site", "treatment", "round", "am_pm", "transect", "species", "slength")spool$slength[is.na(spool$slength)==T] = 0#
# Here, I add the flower count dataflr$f_number<-as.integer(flr$f_number)#flr<-flr[which(flr$year != 2011),]flr = droplevels(flr)flr$Site<-paste(flr$site,flr$year)flr$Site<-as.factor(flr$Site)#
###for correlation without simulation# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#For richness (which sucks)flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))# for the mean quadrat richnessflrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#most steps beyond this line are just to make a row index that allows simulation to runslctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		BS$qnew<-as.factor(BS$qnew)names(slctbl)=c("round", "transect", "quadrat", "slct")#deal with quadrats lacking any flowersBS[BS == 0] <- NAobservedspecimencor.test(flrabu$N, richabund$specrich, method="pearson")cor.test(flrric$N, richabund$specrich, method="pearson")cor.test(flrabu$N, richabund$specabund, method="pearson")cor.test(flrric$N, richabund$specabund, method="pearson")cor.test(flrric2$N, richabund$specabund, method="pearson"
)cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")cor.test(richabund$obsrich,richabund$specrich, method="pearson")
sd(specimen$specrich)
mean(specimen$specrich)
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#it reads in data from all regions from SQL server at Rutgers, and creates summary #tables, computing abundance and species richness#The script also uses R packages you'll need to install. Additionally, I use #the package Hmisc in the subsampling script. #If you don't want to install the packages into your R framework on your computer,#the command below should work whether you have them or not already, and install them#in some temporary folder to allow this script to run. Just uncomment to run#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#these libraries allow creation of abundance and richness vectors, summary tables library(plyr)library(doBy)library(reshape)#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#to compute richness. In our dataset, the
se are unique, with the exception of "sp", which # we are not counting in the richness metric. The summary table created below counts #UNIQUE values, so misspellings will count as separate species, whereas species where two#bees of different genus share a species name will be counted as one.#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQLlibrary(RMySQL)# Access the "R_Winfree_masters" databaseconn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")# List the tables in the databasedbListTables(conn)SpecRaw_MI = dbReadTable(conn, "MI_specimens")flr_MI <-dbReadTable(conn, "MI_flowers")ObsRaw_MI <-dbReadTable(conn, "MI_observations")SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")flr_NJ <-dbReadTable(conn, "NJ_flowers")ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")SpecRaw_CA = dbReadTable(conn, "CA_specimens")flr_CA <-dbReadTable(conn, "CA_flowers")ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:dbListConnections(MySQL())# disconnect this connection from server:dbDisconnect(conn)# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause griefcons = dbListConnections(MySQL())for(con in cons) {  dbDisconnect(con)}## Uncomment below to subset by year#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bindflr <- flr_NJ#ObsRaw <- ObsRaw_NJ#SpecRaw <- SpecRaw_NJ#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#flr <- subset(flr_MI, year =="2013")#ObsRaw <- ObsRaw_CA#str(ObsRaw$csm_group)str(SpecRaw)s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")s.2011<-s
ubset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")SpecRaw<-rbind(s.2013)#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")ObsRaw <-subset(ObsRaw_NJ,  site != "MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")str(ObsRaw)########################################################################################################### Change chr to factorsy###########################################################################################################flr$uniqueID <-as.factor(flr$uniqueID)flr$year <-as.factor(flr$year)flr$site <-as.factor(flr$site)flr$fdate <-as.factor(flr$fdate)flr$round <-as.factor(flr$round)flr$treatment
<-as.factor(flr$treatment)flr$transect <-as.factor(flr$transect)flr$quadrat <-as.factor(flr$quadrat)flr$plant_genus <-as.factor(flr$plant_genus)flr$plant_species <-as.factor(flr$plant_species)#str(flr)ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)ObsRaw$year<-as.factor(ObsRaw$year)ObsRaw$site<-as.factor(ObsRaw$site)ObsRaw$round<-as.factor(ObsRaw$round)ObsRaw$transect<-as.factor(ObsRaw$transect)ObsRaw$section<-as.factor(ObsRaw$section)ObsRaw$treatment<-as.factor(ObsRaw$treatment)ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)ObsRaw$taxa <-as.factor(ObsRaw$taxa)ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#str(ObsRaw)levels(ObsRaw$csm_group)SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)SpecRaw$year<-as.factor(SpecRaw$year)SpecRaw$site<-as.factor(SpecRaw$site)SpecRaw$round<-as.factor(SpecRaw$round)SpecRaw$fdate<-as.factor(SpecRaw$fdate)SpecRaw$transect<-as.factor(SpecRaw$transect)SpecRaw$treatment<-as.factor(SpecRaw$treatment)SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)SpecRaw$Genus <-as.factor(SpecRa
w$Genus)SpecRaw$species <-as.factor(SpecRaw$species)SpecRaw$basicID <-as.factor(SpecRaw$basicID)#str(SpecRaw)#################################################################################################################################################################################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sitesSpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)SpecRaw<-SpecRaw[which(SpecRaw$am_pm=="AM"|SpecRaw$am_pm=="PM"),]#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#summaryBy to create new table with abundance vector. Additional factors (round, #transect...) can be added with + after tilde.summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#summary table with richnesses, called rich#used ddply from plyr to get length of unique values ## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", ## otherwise it will underestimate richness for some sites rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#create a table with number of individuals per transect#numspec<-summaryBy(species ~ Site + site + treatment + transect + round, data=Spec
Raw, FUN=length)SpecRaw<-SpecRaw[which(SpecRaw$basicID == "bee"),]SpecRaw=droplevels(SpecRaw)distinct<-function(x){	length(unique(x))	}rspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), distinct))names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich")rspec$rich[is.na(rspec$rich)==T] = 0numspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), length))names(numspec) = c("Site", "treatment", "round",  "am_pm", "transect", "specnum")numspec$specnum[is.na(numspec$specnum)==T] = 0rspec<-cbind(rspec, numspec$specnum)names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich", "specnum")#combine into one table that now has total richness and abundance per site #(treatment and controls treated as independent)cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column# ObsRaw <- within(ObsRaw, Bombus <- total)# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #Create a native bee abundance columnObsRaw <- within(ObsRaw, ntv <- total)ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon columnObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA # #create a green bee abundance column# ObsRaw <- within(ObsRaw, green <- total)# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 # #create a green bee+Bombus abundance column# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #data cleanupObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]ObsRaw = droplevels(ObsRaw)str(ObsRaw)#For anything that doesn't require a function for unique values, I've used summaryBy, #and ddply only for the richness# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSumsummaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#compute observation "richness" from csm categoriesddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobsob
served<-cbind(ObsSum, richobs$N)#combine to single tablelibrary(reshape)#make sure order is same in both tablesspecimen <-specimen[order(specimen$Site, specimen$treatment),]observed<-observed[order(observed$Site, observed$treatment),]#rename variablesobserved<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))richabund<-cbind(observed, specimen$specrich, specimen$specabund)richabund<-rename(richabund, c("specimen$specrich"="specrich", 	"specimen$specabund"="specabund"))specimen$specrich=as.integer(specimen$specrich)#same thing again, but with round- there's undoubtedly a more elegant way to do this.#this combines the specimen data (where all rounds are combined) with observation data#for each round# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround# summaryBy(
ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround# observedround<-cbind(Obsround, richobsround$N)# # rbind(specimen, specimen, specimen, specimen)->specimenround#make sure order is same in both tables# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]# #rename variables# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", # 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))# # richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", # 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONSspool = melt(tapply (SpecRaw$uniqueID, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, SpecRaw$am_pm, SpecRaw$transect, SpecRaw$species), length))names(spool) = c("Site", "treatment", "round", "am_pm", "transect", "species", "slength")spool$slength[is.na(spool$slength)==T] = 0#
# Here, I add the flower count dataflr$f_number<-as.integer(flr$f_number)#flr<-flr[which(flr$year != 2011),]flr = droplevels(flr)flr$Site<-paste(flr$site,flr$year)flr$Site<-as.factor(flr$Site)#
###for correlation without simulation# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#For richness (which sucks)flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))# for the mean quadrat richnessflrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#most steps beyond this line are just to make a row index that allows simulation to runslctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		BS$qnew<-as.factor(BS$qnew)names(slctbl)=c("round", "transect", "quadrat", "slct")#deal with quadrats lacking any flowersBS[BS == 0] <- NAobservedspecimencor.test(flrabu$N, richabund$specrich, method="pearson")cor.test(flrric$N, richabund$specrich, method="pearson")cor.test(flrabu$N, richabund$specabund, method="pearson")cor.test(flrric$N, richabund$specabund, method="pearson")cor.test(flrric2$N, richabund$specabund, method="pearson"
)cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")cor.test(richabund$obsrich,richabund$specrich, method="pearson")
sd(specimen$specrich)
mean(specimen$specrich)
mean(specimen$specabund)
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#it reads in data from all regions from SQL server at Rutgers, and creates summary #tables, computing abundance and species richness#The script also uses R packages you'll need to install. Additionally, I use #the package Hmisc in the subsampling script. #If you don't want to install the packages into your R framework on your computer,#the command below should work whether you have them or not already, and install them#in some temporary folder to allow this script to run. Just uncomment to run#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#these libraries allow creation of abundance and richness vectors, summary tables library(plyr)library(doBy)library(reshape)#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#to compute richness. In our dataset, the
se are unique, with the exception of "sp", which # we are not counting in the richness metric. The summary table created below counts #UNIQUE values, so misspellings will count as separate species, whereas species where two#bees of different genus share a species name will be counted as one.#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQLlibrary(RMySQL)# Access the "R_Winfree_masters" databaseconn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")# List the tables in the databasedbListTables(conn)SpecRaw_MI = dbReadTable(conn, "MI_specimens")flr_MI <-dbReadTable(conn, "MI_flowers")ObsRaw_MI <-dbReadTable(conn, "MI_observations")SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")flr_NJ <-dbReadTable(conn, "NJ_flowers")ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")SpecRaw_CA = dbReadTable(conn, "CA_specimens")flr_CA <-dbReadTable(conn, "CA_flowers")ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:dbListConnections(MySQL())# disconnect this connection from server:dbDisconnect(conn)# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause griefcons = dbListConnections(MySQL())for(con in cons) {  dbDisconnect(con)}## Uncomment below to subset by year#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bindflr <- flr_NJ#ObsRaw <- ObsRaw_NJ#SpecRaw <- SpecRaw_NJ#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#flr <- subset(flr_MI, year =="2013")#ObsRaw <- ObsRaw_CA#str(ObsRaw$csm_group)str(SpecRaw)s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")s.2011<-s
ubset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")SpecRaw<-rbind(s.2011, s.2012, s.2013)#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")ObsRaw <-subset(ObsRaw_NJ,  site != "MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")str(ObsRaw)########################################################################################################### Change chr to factorsy###########################################################################################################flr$uniqueID <-as.factor(flr$uniqueID)flr$year <-as.factor(flr$year)flr$site <-as.factor(flr$site)flr$fdate <-as.factor(flr$fdate)flr$round <-as.factor(flr$roun
d)flr$treatment <-as.factor(flr$treatment)flr$transect <-as.factor(flr$transect)flr$quadrat <-as.factor(flr$quadrat)flr$plant_genus <-as.factor(flr$plant_genus)flr$plant_species <-as.factor(flr$plant_species)#str(flr)ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)ObsRaw$year<-as.factor(ObsRaw$year)ObsRaw$site<-as.factor(ObsRaw$site)ObsRaw$round<-as.factor(ObsRaw$round)ObsRaw$transect<-as.factor(ObsRaw$transect)ObsRaw$section<-as.factor(ObsRaw$section)ObsRaw$treatment<-as.factor(ObsRaw$treatment)ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)ObsRaw$taxa <-as.factor(ObsRaw$taxa)ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#str(ObsRaw)levels(ObsRaw$csm_group)SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)SpecRaw$year<-as.factor(SpecRaw$year)SpecRaw$site<-as.factor(SpecRaw$site)SpecRaw$round<-as.factor(SpecRaw$round)SpecRaw$fdate<-as.factor(SpecRaw$fdate)SpecRaw$transect<-as.factor(SpecRaw$transect)SpecRaw$treatment<-as.factor(SpecRaw$treatment)SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)SpecRaw$Genus <-
as.factor(SpecRaw$Genus)SpecRaw$species <-as.factor(SpecRaw$species)SpecRaw$basicID <-as.factor(SpecRaw$basicID)#str(SpecRaw)#################################################################################################################################################################################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sitesSpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)SpecRaw<-SpecRaw[which(SpecRaw$am_pm=="AM"|SpecRaw$am_pm=="PM"),]#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#summaryBy to create new table with abundance vector. Additional factors (round, #transect...) can be added with + after tilde.summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#summary table with richnesses, called rich#used ddply from plyr to get length of unique values ## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", ## otherwise it will underestimate richness for some sites rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#create a table with number of individuals per transect#numspec<-summaryBy(species ~ Site + site + treatment + transect + round, data=Spec
Raw, FUN=length)SpecRaw<-SpecRaw[which(SpecRaw$basicID == "bee"),]SpecRaw=droplevels(SpecRaw)distinct<-function(x){	length(unique(x))	}rspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), distinct))names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich")rspec$rich[is.na(rspec$rich)==T] = 0numspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), length))names(numspec) = c("Site", "treatment", "round",  "am_pm", "transect", "specnum")numspec$specnum[is.na(numspec$specnum)==T] = 0rspec<-cbind(rspec, numspec$specnum)names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich", "specnum")#combine into one table that now has total richness and abundance per site #(treatment and controls treated as independent)cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column# ObsRaw <- within(ObsRaw, Bombus <- total)# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #Create a native bee abundance columnObsRaw <- within(ObsRaw, ntv <- total)ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon columnObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA # #create a green bee abundance column# ObsRaw <- within(ObsRaw, green <- total)# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 # #create a green bee+Bombus abundance column# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #data cleanupObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]ObsRaw = droplevels(ObsRaw)str(ObsRaw)#For anything that doesn't require a function for unique values, I've used summaryBy, #and ddply only for the richness# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSumsummaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#compute observation "richness" from csm categoriesddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobsob
served<-cbind(ObsSum, richobs$N)#combine to single tablelibrary(reshape)#make sure order is same in both tablesspecimen <-specimen[order(specimen$Site, specimen$treatment),]observed<-observed[order(observed$Site, observed$treatment),]#rename variablesobserved<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))richabund<-cbind(observed, specimen$specrich, specimen$specabund)richabund<-rename(richabund, c("specimen$specrich"="specrich", 	"specimen$specabund"="specabund"))specimen$specrich=as.integer(specimen$specrich)#same thing again, but with round- there's undoubtedly a more elegant way to do this.#this combines the specimen data (where all rounds are combined) with observation data#for each round# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround# summaryBy(
ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround# observedround<-cbind(Obsround, richobsround$N)# # rbind(specimen, specimen, specimen, specimen)->specimenround#make sure order is same in both tables# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]# #rename variables# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", # 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))# # richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", # 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONSspool = melt(tapply (SpecRaw$uniqueID, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, SpecRaw$am_pm, SpecRaw$transect, SpecRaw$species), length))names(spool) = c("Site", "treatment", "round", "am_pm", "transect", "species", "slength")spool$slength[is.na(spool$slength)==T] = 0#
# Here, I add the flower count dataflr$f_number<-as.integer(flr$f_number)#flr<-flr[which(flr$year != 2011),]flr = droplevels(flr)flr$Site<-paste(flr$site,flr$year)flr$Site<-as.factor(flr$Site)#
###for correlation without simulation# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#For richness (which sucks)flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))# for the mean quadrat richnessflrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#most steps beyond this line are just to make a row index that allows simulation to runslctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		BS$qnew<-as.factor(BS$qnew)names(slctbl)=c("round", "transect", "quadrat", "slct")#deal with quadrats lacking any flowersBS[BS == 0] <- NAobservedspecimencor.test(flrabu$N, richabund$specrich, method="pearson")cor.test(flrric$N, richabund$specrich, method="pearson")cor.test(flrabu$N, richabund$specabund, method="pearson")cor.test(flrric$N, richabund$specabund, method="pearson")cor.test(flrric2$N, richabund$specabund, method="pearson"
)cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")cor.test(richabund$obsrich,richabund$specrich, method="pearson")
mean(specimen$specabund)
100/160
summary(lm(specimen$specrich~specimen$specabund))
s.2011
specimen
#Full dataset subsampling script for streamlined sampling analysis#Script to create a table with random draws without replacement#Roswell 20130528 - Help from James Reilly # The script uses a homemade function, rline, as well as a package, # which must be installed for the script to run properly:# Hmisc# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#next column represents number of 2.5 min sections included in sample#4th column is mean abundance from sample #next two columns are abundance and richness in specimen data#create row label counter#numspec <- fnumspec #fnumspec is the full numspec of sites, rounds etc. This allows you to subset and then after subsetting, return to the full numspec to try another subset again. it<-read.csv("indexing_table.csv", header=T)#numspec <-subset(numspec, round==2|round==4)#numspec0->corlab#Add empty df to populate with subsampling outputsabuncor<-data.frame
()specimen$Site <-as.factor(specimen$Site)spool$Site <- as.factor(spool$Site)# l is number of observations to include in samplefor(l in 1:32){	# m is number of iterations, and larger numbers will slow down script	for(m in 1:20){		0->rlab		#Empty array to populate with for loop		Rabund<-array(dim=c(2*length(unique(spool$Site)),8))		Rabund<-data.frame(Rabund)	# i is an index for the site		for(i in levels(spool$Site)){	# j is index for treatment			for(j in levels(spool$treatment)){				#for(k in c(1:4)){					rlab<-rlab+1					subraw<-data.frame()#
					#Create a table of observations from which to draw					#ijkl<-numspec[which(numspec$site==i & numspec$treatment==j & numspec$round==k),]					ijkl<-spool[which(spool$Site==i & spool$treatment==j),]#
					#sample l observed abundances from 2.5 minute sections 					ssindex<-it[sample(1:32, size=l, replace=F),]					for(s in 1:length(ssindex$round)){						ss<-ssindex[s,]						newrows<-ijkl[which(ijkl$round==ss$round & ijkl$transect==ss$transect & ijkl$am_pm==ss$am_pm),]						subraw<-rbind(subraw,newrows)					}					subpro = melt(tapply (subraw$slength, list(subraw$species), sum))subpro$value[is.na(subpro$value)==T] = 0					sl<- subpro[which(subpro$value>0),]					sr<-length(sl$value)					sa<-sum(subpro$value)					#populate array for step in loop					# first column is site					Rabund[rlab, 1]<-i					# Second column is treatment					Rabund[rlab, 2]<-j					#third column is size of sample					Rabund[rlab, 3]<-l					# fourth column is the mean value for the observations sampled					Rabund[rlab, 4]<-sr					Rabund[rlab, 8]<-sa						#create a limited specimen table of summary specimen results 						speci<-specimen[which(specimen$Site==i & specimen$treatment==j),]					#fifth column is native
bee abundance from the specimen data					Rabund[rlab,5]<-speci$specabund					#sixth column is native bee richness from spec data					Rabund[rlab,6]<-speci$specrich#
					Rabund[rlab, 7]<-m		}}		#Create table of correlations for each number of sections for each iteration		corlab<-corlab+1		abuncor[corlab,1]<-l*10		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]		abuncor[corlab,4]<-mean(Rabund[,8])		}}abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor", V4="specnum"))#
###CONSIDER USING QUANTILES RATHER THAN SE #Create summary table of abuncor with means and SEsstderror<-function(x){(sd(x)/sqrt(length(x)))*1.96}meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
#create panel for plots#par(mfrow=c(1,2))#This library should allow me to plot error barslibrary(Hmisc)#GENERATE PLOTS#quartz()#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #	xlab=paste("sampling effort \n (minutes)", sep="\n"),#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#	pch = 20, type = 'p'))#abline(h=0.964)#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#	col = 'red')quartz()with(meanSEs, errbar(specnum.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (number of specimens)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2
)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
quartz()with(meanSEs, errbar(sections.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')detach(package:Hmisc)
library(reshape)
#Full dataset subsampling script for streamlined sampling analysis#Script to create a table with random draws without replacement#Roswell 20130528 - Help from James Reilly # The script uses a homemade function, rline, as well as a package, # which must be installed for the script to run properly:# Hmisc# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#next column represents number of 2.5 min sections included in sample#4th column is mean abundance from sample #next two columns are abundance and richness in specimen data#create row label counter#numspec <- fnumspec #fnumspec is the full numspec of sites, rounds etc. This allows you to subset and then after subsetting, return to the full numspec to try another subset again. it<-read.csv("indexing_table.csv", header=T)#numspec <-subset(numspec, round==2|round==4)#numspec0->corlab#Add empty df to populate with subsampling outputsabuncor<-data.frame
()specimen$Site <-as.factor(specimen$Site)spool$Site <- as.factor(spool$Site)# l is number of observations to include in samplefor(l in 1:32){	# m is number of iterations, and larger numbers will slow down script	for(m in 1:20){		0->rlab		#Empty array to populate with for loop		Rabund<-array(dim=c(2*length(unique(spool$Site)),8))		Rabund<-data.frame(Rabund)	# i is an index for the site		for(i in levels(spool$Site)){	# j is index for treatment			for(j in levels(spool$treatment)){				#for(k in c(1:4)){					rlab<-rlab+1					subraw<-data.frame()#
					#Create a table of observations from which to draw					#ijkl<-numspec[which(numspec$site==i & numspec$treatment==j & numspec$round==k),]					ijkl<-spool[which(spool$Site==i & spool$treatment==j),]#
					#sample l observed abundances from 2.5 minute sections 					ssindex<-it[sample(1:32, size=l, replace=F),]					for(s in 1:length(ssindex$round)){						ss<-ssindex[s,]						newrows<-ijkl[which(ijkl$round==ss$round & ijkl$transect==ss$transect & ijkl$am_pm==ss$am_pm),]						subraw<-rbind(subraw,newrows)					}					subpro = melt(tapply (subraw$slength, list(subraw$species), sum))subpro$value[is.na(subpro$value)==T] = 0					sl<- subpro[which(subpro$value>0),]					sr<-length(sl$value)					sa<-sum(subpro$value)					#populate array for step in loop					# first column is site					Rabund[rlab, 1]<-i					# Second column is treatment					Rabund[rlab, 2]<-j					#third column is size of sample					Rabund[rlab, 3]<-l					# fourth column is the mean value for the observations sampled					Rabund[rlab, 4]<-sr					Rabund[rlab, 8]<-sa						#create a limited specimen table of summary specimen results 						speci<-specimen[which(specimen$Site==i & specimen$treatment==j),]					#fifth column is native
bee abundance from the specimen data					Rabund[rlab,5]<-speci$specabund					#sixth column is native bee richness from spec data					Rabund[rlab,6]<-speci$specrich#
					Rabund[rlab, 7]<-m		}}		#Create table of correlations for each number of sections for each iteration		corlab<-corlab+1		abuncor[corlab,1]<-l*10		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]		abuncor[corlab,4]<-mean(Rabund[,8])		}}abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor", V4="specnum"))#
###CONSIDER USING QUANTILES RATHER THAN SE #Create summary table of abuncor with means and SEsstderror<-function(x){(sd(x)/sqrt(length(x)))*1.96}meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
#create panel for plots#par(mfrow=c(1,2))#This library should allow me to plot error barslibrary(Hmisc)#GENERATE PLOTS#quartz()#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #	xlab=paste("sampling effort \n (minutes)", sep="\n"),#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#	pch = 20, type = 'p'))#abline(h=0.964)#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#	col = 'red')quartz()with(meanSEs, errbar(specnum.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (number of specimens)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2
)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
quartz()with(meanSEs, errbar(sections.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')detach(package:Hmisc)
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#it reads in data from all regions from SQL server at Rutgers, and creates summary #tables, computing abundance and species richness#The script also uses R packages you'll need to install. Additionally, I use #the package Hmisc in the subsampling script. #If you don't want to install the packages into your R framework on your computer,#the command below should work whether you have them or not already, and install them#in some temporary folder to allow this script to run. Just uncomment to run#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#these libraries allow creation of abundance and richness vectors, summary tables library(plyr)library(doBy)library(reshape)#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#to compute richness. In our dataset, the
se are unique, with the exception of "sp", which # we are not counting in the richness metric. The summary table created below counts #UNIQUE values, so misspellings will count as separate species, whereas species where two#bees of different genus share a species name will be counted as one.#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQLlibrary(RMySQL)# Access the "R_Winfree_masters" databaseconn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")# List the tables in the databasedbListTables(conn)SpecRaw_MI = dbReadTable(conn, "MI_specimens")flr_MI <-dbReadTable(conn, "MI_flowers")ObsRaw_MI <-dbReadTable(conn, "MI_observations")SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")flr_NJ <-dbReadTable(conn, "NJ_flowers")ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")SpecRaw_CA = dbReadTable(conn, "CA_specimens")flr_CA <-dbReadTable(conn, "CA_flowers")ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:dbListConnections(MySQL())# disconnect this connection from server:dbDisconnect(conn)# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause griefcons = dbListConnections(MySQL())for(con in cons) {  dbDisconnect(con)}## Uncomment below to subset by year#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bindflr <- flr_NJ#ObsRaw <- ObsRaw_NJ#SpecRaw <- SpecRaw_NJ#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#flr <- subset(flr_MI, year =="2013")#ObsRaw <- ObsRaw_CA#str(ObsRaw$csm_group)str(SpecRaw)s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")s.2011<-s
ubset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")SpecRaw<-rbind(s.2011, s.2012, s.2013)#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")ObsRaw <-subset(ObsRaw_NJ,  site != "MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")str(ObsRaw)########################################################################################################### Change chr to factorsy###########################################################################################################flr$uniqueID <-as.factor(flr$uniqueID)flr$year <-as.factor(flr$year)flr$site <-as.factor(flr$site)flr$fdate <-as.factor(flr$fdate)flr$round <-as.factor(flr$roun
d)flr$treatment <-as.factor(flr$treatment)flr$transect <-as.factor(flr$transect)flr$quadrat <-as.factor(flr$quadrat)flr$plant_genus <-as.factor(flr$plant_genus)flr$plant_species <-as.factor(flr$plant_species)#str(flr)ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)ObsRaw$year<-as.factor(ObsRaw$year)ObsRaw$site<-as.factor(ObsRaw$site)ObsRaw$round<-as.factor(ObsRaw$round)ObsRaw$transect<-as.factor(ObsRaw$transect)ObsRaw$section<-as.factor(ObsRaw$section)ObsRaw$treatment<-as.factor(ObsRaw$treatment)ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)ObsRaw$taxa <-as.factor(ObsRaw$taxa)ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#str(ObsRaw)levels(ObsRaw$csm_group)SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)SpecRaw$year<-as.factor(SpecRaw$year)SpecRaw$site<-as.factor(SpecRaw$site)SpecRaw$round<-as.factor(SpecRaw$round)SpecRaw$fdate<-as.factor(SpecRaw$fdate)SpecRaw$transect<-as.factor(SpecRaw$transect)SpecRaw$treatment<-as.factor(SpecRaw$treatment)SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)SpecRaw$Genus <-
as.factor(SpecRaw$Genus)SpecRaw$species <-as.factor(SpecRaw$species)SpecRaw$basicID <-as.factor(SpecRaw$basicID)#str(SpecRaw)#################################################################################################################################################################################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sitesSpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)SpecRaw<-SpecRaw[which(SpecRaw$am_pm=="AM"|SpecRaw$am_pm=="PM"),]#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#summaryBy to create new table with abundance vector. Additional factors (round, #transect...) can be added with + after tilde.summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#summary table with richnesses, called rich#used ddply from plyr to get length of unique values ## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", ## otherwise it will underestimate richness for some sites rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#create a table with number of individuals per transect#numspec<-summaryBy(species ~ Site + site + treatment + transect + round, data=Spec
Raw, FUN=length)SpecRaw<-SpecRaw[which(SpecRaw$basicID == "bee"),]SpecRaw=droplevels(SpecRaw)distinct<-function(x){	length(unique(x))	}rspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), distinct))names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich")rspec$rich[is.na(rspec$rich)==T] = 0numspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), length))names(numspec) = c("Site", "treatment", "round",  "am_pm", "transect", "specnum")numspec$specnum[is.na(numspec$specnum)==T] = 0rspec<-cbind(rspec, numspec$specnum)names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich", "specnum")#combine into one table that now has total richness and abundance per site #(treatment and controls treated as independent)cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column# ObsRaw <- within(ObsRaw, Bombus <- total)# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #Create a native bee abundance columnObsRaw <- within(ObsRaw, ntv <- total)ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon columnObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA # #create a green bee abundance column# ObsRaw <- within(ObsRaw, green <- total)# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 # #create a green bee+Bombus abundance column# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #data cleanupObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]ObsRaw = droplevels(ObsRaw)str(ObsRaw)#For anything that doesn't require a function for unique values, I've used summaryBy, #and ddply only for the richness# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSumsummaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#compute observation "richness" from csm categoriesddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobsob
served<-cbind(ObsSum, richobs$N)#combine to single tablelibrary(reshape)#make sure order is same in both tablesspecimen <-specimen[order(specimen$Site, specimen$treatment),]observed<-observed[order(observed$Site, observed$treatment),]#rename variablesobserved<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))richabund<-cbind(observed, specimen$specrich, specimen$specabund)richabund<-rename(richabund, c("specimen$specrich"="specrich", 	"specimen$specabund"="specabund"))specimen$specrich=as.integer(specimen$specrich)#same thing again, but with round- there's undoubtedly a more elegant way to do this.#this combines the specimen data (where all rounds are combined) with observation data#for each round# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround# summaryBy(
ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround# observedround<-cbind(Obsround, richobsround$N)# # rbind(specimen, specimen, specimen, specimen)->specimenround#make sure order is same in both tables# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]# #rename variables# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", # 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))# # richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", # 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONSspool = melt(tapply (SpecRaw$uniqueID, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, SpecRaw$am_pm, SpecRaw$transect, SpecRaw$species), length))names(spool) = c("Site", "treatment", "round", "am_pm", "transect", "species", "slength")spool$slength[is.na(spool$slength)==T] = 0#
# Here, I add the flower count dataflr$f_number<-as.integer(flr$f_number)#flr<-flr[which(flr$year != 2011),]flr = droplevels(flr)flr$Site<-paste(flr$site,flr$year)flr$Site<-as.factor(flr$Site)#
###for correlation without simulation# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#For richness (which sucks)flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))# for the mean quadrat richnessflrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#most steps beyond this line are just to make a row index that allows simulation to runslctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		BS$qnew<-as.factor(BS$qnew)names(slctbl)=c("round", "transect", "quadrat", "slct")#deal with quadrats lacking any flowersBS[BS == 0] <- NAobservedspecimencor.test(flrabu$N, richabund$specrich, method="pearson")cor.test(flrric$N, richabund$specrich, method="pearson")cor.test(flrabu$N, richabund$specabund, method="pearson")cor.test(flrric$N, richabund$specabund, method="pearson")cor.test(flrric2$N, richabund$specabund, method="pearson"
)cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Full dataset subsampling script for streamlined sampling analysis#Script to create a table with random draws without replacement#Roswell 20130528 - Help from James Reilly # The script uses a homemade function, rline, as well as a package, # which must be installed for the script to run properly:# Hmisc# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#next column represents number of 2.5 min sections included in sample#4th column is mean abundance from sample #next two columns are abundance and richness in specimen data#create row label counter#numspec <- fnumspec #fnumspec is the full numspec of sites, rounds etc. This allows you to subset and then after subsetting, return to the full numspec to try another subset again. it<-read.csv("indexing_table.csv", header=T)#numspec <-subset(numspec, round==2|round==4)#numspec0->corlab#Add empty df to populate with subsampling outputsabuncor<-data.frame
()specimen$Site <-as.factor(specimen$Site)spool$Site <- as.factor(spool$Site)# l is number of observations to include in samplefor(l in 1:32){	# m is number of iterations, and larger numbers will slow down script	for(m in 1:20){		0->rlab		#Empty array to populate with for loop		Rabund<-array(dim=c(2*length(unique(spool$Site)),8))		Rabund<-data.frame(Rabund)	# i is an index for the site		for(i in levels(spool$Site)){	# j is index for treatment			for(j in levels(spool$treatment)){				#for(k in c(1:4)){					rlab<-rlab+1					subraw<-data.frame()#
					#Create a table of observations from which to draw					#ijkl<-numspec[which(numspec$site==i & numspec$treatment==j & numspec$round==k),]					ijkl<-spool[which(spool$Site==i & spool$treatment==j),]#
					#sample l observed abundances from 2.5 minute sections 					ssindex<-it[sample(1:32, size=l, replace=F),]					for(s in 1:length(ssindex$round)){						ss<-ssindex[s,]						newrows<-ijkl[which(ijkl$round==ss$round & ijkl$transect==ss$transect & ijkl$am_pm==ss$am_pm),]						subraw<-rbind(subraw,newrows)					}					subpro = melt(tapply (subraw$slength, list(subraw$species), sum))subpro$value[is.na(subpro$value)==T] = 0					sl<- subpro[which(subpro$value>0),]					sr<-length(sl$value)					sa<-sum(subpro$value)					#populate array for step in loop					# first column is site					Rabund[rlab, 1]<-i					# Second column is treatment					Rabund[rlab, 2]<-j					#third column is size of sample					Rabund[rlab, 3]<-l					# fourth column is the mean value for the observations sampled					Rabund[rlab, 4]<-sr					Rabund[rlab, 8]<-sa						#create a limited specimen table of summary specimen results 						speci<-specimen[which(specimen$Site==i & specimen$treatment==j),]					#fifth column is native
bee abundance from the specimen data					Rabund[rlab,5]<-speci$specabund					#sixth column is native bee richness from spec data					Rabund[rlab,6]<-speci$specrich#
					Rabund[rlab, 7]<-m		}}		#Create table of correlations for each number of sections for each iteration		corlab<-corlab+1		abuncor[corlab,1]<-l*10		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]		abuncor[corlab,4]<-mean(Rabund[,8])		}}abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor", V4="specnum"))#
###CONSIDER USING QUANTILES RATHER THAN SE #Create summary table of abuncor with means and SEsstderror<-function(x){(sd(x)/sqrt(length(x)))*1.96}meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
#create panel for plots#par(mfrow=c(1,2))#This library should allow me to plot error barslibrary(Hmisc)#GENERATE PLOTS#quartz()#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #	xlab=paste("sampling effort \n (minutes)", sep="\n"),#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#	pch = 20, type = 'p'))#abline(h=0.964)#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#	col = 'red')quartz()with(meanSEs, errbar(specnum.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (number of specimens)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2
)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
quartz()with(meanSEs, errbar(sections.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')detach(package:Hmisc)
#Michael Roswell (mike.roswell@gmail.com) and Dan Cariveau (dancariveau@gmail.com) #This is the data read-in script that should work for the simulation and graphing scripts in the CIG streamlined project.#it reads in data from all regions from SQL server at Rutgers, and creates summary #tables, computing abundance and species richness#The script also uses R packages you'll need to install. Additionally, I use #the package Hmisc in the subsampling script. #If you don't want to install the packages into your R framework on your computer,#the command below should work whether you have them or not already, and install them#in some temporary folder to allow this script to run. Just uncomment to run#install.packages(c("doBy", "plyr", "Hmisc", "reshape"))#these libraries allow creation of abundance and richness vectors, summary tables library(plyr)library(doBy)library(reshape)#NOTE: for the NJ data, we use only the "species name" (i.e. impatiens) column#to compute richness. In our dataset, the
se are unique, with the exception of "sp", which # we are not counting in the richness metric. The summary table created below counts #UNIQUE values, so misspellings will count as separate species, whereas species where two#bees of different genus share a species name will be counted as one.#NOTE: watch for confusing use of two variables, 'site' (just site name) and 'Site' (site name and year concatenated)  #
#GET DATA FROM SQLlibrary(RMySQL)# Access the "R_Winfree_masters" databaseconn <- dbConnect(dbDriver("MySQL"), user="CIG_user", password="nativebee",                  dbname="CIG_shared", port = 8889 , host= "165.230.174.165")# List the tables in the databasedbListTables(conn)SpecRaw_MI = dbReadTable(conn, "MI_specimens")flr_MI <-dbReadTable(conn, "MI_flowers")ObsRaw_MI <-dbReadTable(conn, "MI_observations")SpecRaw_NJ = dbReadTable(conn, "NJ_specimens")flr_NJ <-dbReadTable(conn, "NJ_flowers")ObsRaw_NJ <-dbReadTable(conn, "NJ_observations")SpecRaw_CA = dbReadTable(conn, "CA_specimens")flr_CA <-dbReadTable(conn, "CA_flowers")ObsRaw_CA <-dbReadTable(conn, "CA_observations")#
# list the connections you have open:dbListConnections(MySQL())# disconnect this connection from server:dbDisconnect(conn)# close all the connections! It is important to close connections when you're done with them.  Otherwise they pile up over time and cause griefcons = dbListConnections(MySQL())for(con in cons) {  dbDisconnect(con)}## Uncomment below to subset by year#SpecRaw_NJ <-subset(SpecRaw_NJ, year=="2012")## Change state abbreviation after underscore to choose a different region, or store multiple regions with an r-bindflr <- flr_NJ#ObsRaw <- ObsRaw_NJ#SpecRaw <- SpecRaw_NJ#ObsRaw <- subset(ObsRaw_NJ, year == "2012")#SpecRaw <- subset(SpecRaw_NJ, year =="2012")#flr <- subset(flr_MI, year =="2013")#ObsRaw <- ObsRaw_CA#str(ObsRaw$csm_group)str(SpecRaw)s.2013<-subset(SpecRaw_NJ, year=="2013" & project=="NCIG" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="UR")s.2012<-subset(SpecRaw_NJ, year=="2012" &site!="MO")s.2011<-s
ubset(SpecRaw_NJ, year=="2011" &site !="MO" &treatment !="NA")SpecRaw<-rbind(s.2011, s.2012, s.2013)#SpecRaw <-subset(SpecRaw_NJ, year=="2012" & site !="MO")ObsRaw <-subset(ObsRaw_NJ,  site != "MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")#SpecRaw<-subset(SpecRaw_NJ, year =="2012" & treatment!="NA" & site !="MO" & site!="AB"& site!="AL" & site!="WO" & site!="BW" & site!="BO" & site!="MA"  & site!="RO"  & site!="URWA" )#SpecRaw <-subset(SpecRaw_NJ, year=="2013" & site !="MO")#ObsRaw <-subset(ObsRaw_NJ, year=="2012" & site !="MO")#flr <- subset(flr_NJ, year=="2012" & site !="MO")str(ObsRaw)########################################################################################################### Change chr to factorsy###########################################################################################################flr$uniqueID <-as.factor(flr$uniqueID)flr$year <-as.factor(flr$year)flr$site <-as.factor(flr$site)flr$fdate <-as.factor(flr$fdate)flr$round <-as.factor(flr$roun
d)flr$treatment <-as.factor(flr$treatment)flr$transect <-as.factor(flr$transect)flr$quadrat <-as.factor(flr$quadrat)flr$plant_genus <-as.factor(flr$plant_genus)flr$plant_species <-as.factor(flr$plant_species)#str(flr)ObsRaw$uniqueID<-as.factor(ObsRaw$uniqueID)ObsRaw$year<-as.factor(ObsRaw$year)ObsRaw$site<-as.factor(ObsRaw$site)ObsRaw$round<-as.factor(ObsRaw$round)ObsRaw$transect<-as.factor(ObsRaw$transect)ObsRaw$section<-as.factor(ObsRaw$section)ObsRaw$treatment<-as.factor(ObsRaw$treatment)ObsRaw$am_pm<-as.factor(ObsRaw$am_pm)ObsRaw$taxa <-as.factor(ObsRaw$taxa)ObsRaw$csm_group<-as.factor(ObsRaw$csm_group)#str(ObsRaw)levels(ObsRaw$csm_group)SpecRaw$uniqueID<-as.factor(SpecRaw$uniqueID)SpecRaw$year<-as.factor(SpecRaw$year)SpecRaw$site<-as.factor(SpecRaw$site)SpecRaw$round<-as.factor(SpecRaw$round)SpecRaw$fdate<-as.factor(SpecRaw$fdate)SpecRaw$transect<-as.factor(SpecRaw$transect)SpecRaw$treatment<-as.factor(SpecRaw$treatment)SpecRaw$am_pm<-as.factor(SpecRaw$am_pm)SpecRaw$Genus <-
as.factor(SpecRaw$Genus)SpecRaw$species <-as.factor(SpecRaw$species)SpecRaw$basicID <-as.factor(SpecRaw$basicID)#str(SpecRaw)#################################################################################################################################################################################################################
#Datacleanup steps-> Null to NA, oncatenate site and year to distinguish repeated sitesSpecRaw <- SpecRaw[ which(SpecRaw$species!='NULL'), ]SpecRaw$Site<-paste(SpecRaw$site,SpecRaw$year)SpecRaw<-SpecRaw[which(SpecRaw$am_pm=="AM"|SpecRaw$am_pm=="PM"),]#create a sepcimen abundance vector (site including treatment, but not differentiated by round)#summaryBy to create new table with abundance vector. Additional factors (round, #transect...) can be added with + after tilde.summaryBy(species ~ Site + site + treatment, data=SpecRaw, FUN=length)->abund#summary table with richnesses, called rich#used ddply from plyr to get length of unique values ## DOUBLE CHECK!!! unique(species)-1 only makes sense if EVERY site has a "sp", ## otherwise it will underestimate richness for some sites rich <- ddply(SpecRaw, .(Site, treatment), summarise,  N=length(unique(species))-1)#create a table with number of individuals per transect#numspec<-summaryBy(species ~ Site + site + treatment + transect + round, data=Spec
Raw, FUN=length)SpecRaw<-SpecRaw[which(SpecRaw$basicID == "bee"),]SpecRaw=droplevels(SpecRaw)distinct<-function(x){	length(unique(x))	}rspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), distinct))names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich")rspec$rich[is.na(rspec$rich)==T] = 0numspec = melt(tapply (SpecRaw$species, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, 	SpecRaw$am_pm, SpecRaw$transect), length))names(numspec) = c("Site", "treatment", "round",  "am_pm", "transect", "specnum")numspec$specnum[is.na(numspec$specnum)==T] = 0rspec<-cbind(rspec, numspec$specnum)names(rspec) = c("Site", "treatment", "round",  "am_pm", "transect", "rich", "specnum")#combine into one table that now has total richness and abundance per site #(treatment and controls treated as independent)cbind(abund, rich$N)->specimen#
# #Create a bombus abundance column# ObsRaw <- within(ObsRaw, Bombus <- total)# ObsRaw[!(ObsRaw$csm_group=="Bombus"), "Bombus"] <-0 #Create a native bee abundance columnObsRaw <- within(ObsRaw, ntv <- total)ObsRaw[!(ObsRaw$taxa=="bee"), "ntv"] <-0 #
#Create a native bee taxon columnObsRaw <- within(ObsRaw, nativebeegroup <- csm_group)ObsRaw[!(ObsRaw$taxa=="bee"), "nativebeegroup"] <-NA # #create a green bee abundance column# ObsRaw <- within(ObsRaw, green <- total)# ObsRaw[(ObsRaw$csm_group!="green"), "green"] <-0 # #create a green bee+Bombus abundance column# ObsRaw <- within(ObsRaw, Bombusplusgreen <- total)# ObsRaw[!(ObsRaw$csm_group=="green"| ObsRaw$csm_group=="Bombus"), "Bombusplusgreen"] <-0 #data cleanupObsRaw$Site<-paste(ObsRaw$site,ObsRaw$year)#ObsRaw<- ObsRaw[which(ObsRaw$site!=" "), ]ObsRaw = droplevels(ObsRaw)str(ObsRaw)#For anything that doesn't require a function for unique values, I've used summaryBy, #and ddply only for the richness# summaryBy(ntv+Bombus+green+Bombusplusgreen~site+T_C, data=ObsRaw, FUN=sum)->ObsSumsummaryBy(ntv~Site+treatment, data=ObsRaw, FUN=sum)->ObsSum#compute observation "richness" from csm categoriesddply(ObsRaw, .(Site, treatment), summarise,  N=length(unique(nativebeegroup))) ->richobsob
served<-cbind(ObsSum, richobs$N)#combine to single tablelibrary(reshape)#make sure order is same in both tablesspecimen <-specimen[order(specimen$Site, specimen$treatment),]observed<-observed[order(observed$Site, observed$treatment),]#rename variablesobserved<-rename(observed, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))specimen<-rename(specimen, c("species.length"="specabund", "rich$N"="specrich"))richabund<-cbind(observed, specimen$specrich, specimen$specabund)richabund<-rename(richabund, c("specimen$specrich"="specrich", 	"specimen$specabund"="specabund"))specimen$specrich=as.integer(specimen$specrich)#same thing again, but with round- there's undoubtedly a more elegant way to do this.#this combines the specimen data (where all rounds are combined) with observation data#for each round# # summaryBy(ntv+Bombus+green+Bombusplusgreen~Site+treatment+round, data=ObsRaw, FUN=sum)->Obsround# summaryBy(
ntv~site+T_C+round, data=ObsRaw, FUN=sum)->Obsround# ddply(ObsRaw, .(site, T_C, round), summarize,  N=length(unique(nativebeegroup))) ->richobsround# observedround<-cbind(Obsround, richobsround$N)# # rbind(specimen, specimen, specimen, specimen)->specimenround#make sure order is same in both tables# specimenround <-specimenround[order(specimenround$Site, specimenround$treatment),]# observedround<-observedround[order( observedround$site, observedround$T_C, observedround$round),]# #rename variables# observedround<-rename(observedround, c("richobs$N"="obsrich",  "ntv.sum"="obsabund", # 	"Bombus.sum"="Bombus", "green.sum"="green", "Bombusplusgreen.sum"="Bombusplusgreen"))# specimenround<-rename(specimenround, c("species.length"="specabund", "rich$N"="specrich"))# # richabundround<-cbind(observedround, specimenround$specrich, specimenround$specabund)# richabundround<-rename(richabundround, c("specimenround$specrich"="specrich", # 	"specimenround$specabund"="specabund"))#
### THIS GETS AROUND THE MISSING PM ROUNDS, ADD ZEROS WHEN NO OBSERVATIONSspool = melt(tapply (SpecRaw$uniqueID, list(SpecRaw$Site, SpecRaw$treatment, SpecRaw$round, SpecRaw$am_pm, SpecRaw$transect, SpecRaw$species), length))names(spool) = c("Site", "treatment", "round", "am_pm", "transect", "species", "slength")spool$slength[is.na(spool$slength)==T] = 0#
# Here, I add the flower count dataflr$f_number<-as.integer(flr$f_number)#flr<-flr[which(flr$year != 2011),]flr = droplevels(flr)flr$Site<-paste(flr$site,flr$year)flr$Site<-as.factor(flr$Site)#
###for correlation without simulation# flrabu<-ddply(flr, .(Site, T_C, round, Tran, Quadrat), summarize,  N=sum(f_number))flrabu<-ddply(flr, .(Site, treatment), summarise,  N=sum(f_number))#For richness (which sucks)flrric<-ddply(flr, .(Site, treatment), summarise,  N=length(unique(plant_genus)))# for the mean quadrat richnessflrric2<-ddply(flr, .(Site, treatment), summarise,  N=length(plant_species))#
BS<-ddply(flr, .(Site, treatment, round, transect, quadrat), summarise,  unique(plant_species))BS[,7]<-paste(BS$round,BS$transect, BS$quadrat)#most steps beyond this line are just to make a row index that allows simulation to runslctbl<-ddply(flr, .(round, transect, quadrat), summarise,  N=sum(f_number))slctbl[,4]<-paste(slctbl$round, slctbl$transect, slctbl$quadrat)#this line is problematic because it switches secretly from site=site to site=siteyear, elsewhere known as Site.names(BS)=c("site", "treatment", "round", "transect", "quadrat", "plant", "qnew")		BS$qnew<-as.factor(BS$qnew)names(slctbl)=c("round", "transect", "quadrat", "slct")#deal with quadrats lacking any flowersBS[BS == 0] <- NAobservedspecimencor.test(flrabu$N, richabund$specrich, method="pearson")cor.test(flrric$N, richabund$specrich, method="pearson")cor.test(flrabu$N, richabund$specabund, method="pearson")cor.test(flrric$N, richabund$specabund, method="pearson")cor.test(flrric2$N, richabund$specabund, method="pearson"
)cor.test(flrric2$N, richabund$specabund, method="pearson")#
cor.test(richabund$obsabun,richabund$specrich, method="pearson")cor.test(richabund$obsrich,richabund$specrich, method="pearson")
#Full dataset subsampling script for streamlined sampling analysis#Script to create a table with random draws without replacement#Roswell 20130528 - Help from James Reilly # The script uses a homemade function, rline, as well as a package, # which must be installed for the script to run properly:# Hmisc# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#next column represents number of 2.5 min sections included in sample#4th column is mean abundance from sample #next two columns are abundance and richness in specimen data#create row label counter#numspec <- fnumspec #fnumspec is the full numspec of sites, rounds etc. This allows you to subset and then after subsetting, return to the full numspec to try another subset again. it<-read.csv("indexing_table.csv", header=T)#numspec <-subset(numspec, round==2|round==4)#numspec0->corlab#Add empty df to populate with subsampling outputsabuncor<-data.frame
()specimen$Site <-as.factor(specimen$Site)spool$Site <- as.factor(spool$Site)# l is number of observations to include in samplefor(l in 1:32){	# m is number of iterations, and larger numbers will slow down script	for(m in 1:20){		0->rlab		#Empty array to populate with for loop		Rabund<-array(dim=c(2*length(unique(spool$Site)),8))		Rabund<-data.frame(Rabund)	# i is an index for the site		for(i in levels(spool$Site)){	# j is index for treatment			for(j in levels(spool$treatment)){				#for(k in c(1:4)){					rlab<-rlab+1					subraw<-data.frame()#
					#Create a table of observations from which to draw					#ijkl<-numspec[which(numspec$site==i & numspec$treatment==j & numspec$round==k),]					ijkl<-spool[which(spool$Site==i & spool$treatment==j),]#
					#sample l observed abundances from 2.5 minute sections 					ssindex<-it[sample(1:32, size=l, replace=F),]					for(s in 1:length(ssindex$round)){						ss<-ssindex[s,]						newrows<-ijkl[which(ijkl$round==ss$round & ijkl$transect==ss$transect & ijkl$am_pm==ss$am_pm),]						subraw<-rbind(subraw,newrows)					}					subpro = melt(tapply (subraw$slength, list(subraw$species), sum))subpro$value[is.na(subpro$value)==T] = 0					sl<- subpro[which(subpro$value>0),]					sr<-length(sl$value)					sa<-sum(subpro$value)					#populate array for step in loop					# first column is site					Rabund[rlab, 1]<-i					# Second column is treatment					Rabund[rlab, 2]<-j					#third column is size of sample					Rabund[rlab, 3]<-l					# fourth column is the mean value for the observations sampled					Rabund[rlab, 4]<-sr					Rabund[rlab, 8]<-sa						#create a limited specimen table of summary specimen results 						speci<-specimen[which(specimen$Site==i & specimen$treatment==j),]					#fifth column is native
bee abundance from the specimen data					Rabund[rlab,5]<-speci$specabund					#sixth column is native bee richness from spec data					Rabund[rlab,6]<-speci$specrich#
					Rabund[rlab, 7]<-m		}}		#Create table of correlations for each number of sections for each iteration		corlab<-corlab+1		abuncor[corlab,1]<-l*10		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]		abuncor[corlab,4]<-mean(Rabund[,8])		}}abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor", V4="specnum"))#
###CONSIDER USING QUANTILES RATHER THAN SE #Create summary table of abuncor with means and SEsstderror<-function(x){(sd(x)/sqrt(length(x)))*1.96}meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
#create panel for plots#par(mfrow=c(1,2))#This library should allow me to plot error barslibrary(Hmisc)#GENERATE PLOTS#quartz()#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #	xlab=paste("sampling effort \n (minutes)", sep="\n"),#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#	pch = 20, type = 'p'))#abline(h=0.964)#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#	col = 'red')quartz()with(meanSEs, errbar(specnum.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (number of specimens)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2
)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
quartz()with(meanSEs, errbar(sections.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')detach(package:Hmisc)
str(ijkl)
str(ss)
y = c(8.3, 8.6, 10.7, 10.8, 11, 11, 11.1, 11.2, 11.3, 11.4)
y
y>10
quartz()
plot(y,y)
dat <- data.frame(species = c("S.altissima", "S.rugosa", "E. graminifolia", "A.pilosus"), treatment = factor(c("Control", "Water", "Control", "Water")), height = c(1.1, 0.8, 0.9, 1), width = c(1, 1.7, 0.6, 0.2))dat #you can extract elements using indices, as in matrices#examples#the second rowdat[2,]#the 4th column in the 3rd rowdat[3,4]#the 2nd column, this is a factor, so it gives levels as well.dat[,2]#all rows where the value of column 2, treatment = water.dat[dat[,2] =="Water",]#this does the same thing as the line above.subset(dat, treatment == "Water")#Factors -treated as a separate class of data, useful in experimental design.#ordered alphabetically by default.# The following shows how each part of the full xpression works.#create a vector of 3 character variables.c("Control", "Medium", "High") #repeat that so that each variable occurs 3 times.rep(c("Control", "Medium", "High"), each = 3)#assign those values to a factor object, and name it treatment.#Note that unde
r levels, these are listed alphabetically.Treatment <- factor(rep(c("Control", "Medium", "High"), each = 3))Treatment#ordering of levels can be important when we plot things.levels(Treatment)stripchart(1:9 ~ Treatment)
#Full dataset subsampling script for streamlined sampling analysis#Script to create a table with random draws without replacement#Roswell 20130528 - Help from James Reilly # The script uses a homemade function, rline, as well as a package, # which must be installed for the script to run properly:# Hmisc# AGAIN, SCRIPT WILL FAIL IF PACKAGES ARE NOT INSTALLED#nested for loop to populate matrix Rabund. First 2 columns represent site, treatment.#next column represents number of 2.5 min sections included in sample#4th column is mean abundance from sample #next two columns are abundance and richness in specimen data#create row label counter#numspec <- fnumspec #fnumspec is the full numspec of sites, rounds etc. This allows you to subset and then after subsetting, return to the full numspec to try another subset again. it<-read.csv("indexing_table.csv", header=T)#numspec <-subset(numspec, round==2|round==4)#numspec0->corlab#Add empty df to populate with subsampling outputsabuncor<-data.frame
()specimen$Site <-as.factor(specimen$Site)spool$Site <- as.factor(spool$Site)# l is number of observations to include in samplefor(l in 1:32){	# m is number of iterations, and larger numbers will slow down script	for(m in 1:20){		0->rlab		#Empty array to populate with for loop		Rabund<-array(dim=c(2*length(unique(spool$Site)),8))		Rabund<-data.frame(Rabund)	# i is an index for the site		for(i in levels(spool$Site)){	# j is index for treatment			for(j in levels(spool$treatment)){				#for(k in c(1:4)){					rlab<-rlab+1					subraw<-data.frame()#
					#Create a table of observations from which to draw					#ijkl<-numspec[which(numspec$site==i & numspec$treatment==j & numspec$round==k),]					ijkl<-spool[which(spool$Site==i & spool$treatment==j),]#
					#sample l observed abundances from 2.5 minute sections 					ssindex<-it[sample(1:32, size=l, replace=F),]					for(s in 1:length(ssindex$round)){						ss<-ssindex[s,]						newrows<-ijkl[which(ijkl$round==ss$round & ijkl$transect==ss$transect & ijkl$am_pm==ss$am_pm),]						subraw<-rbind(subraw,newrows)					}					subpro = melt(tapply (subraw$slength, list(subraw$species), sum))subpro$value[is.na(subpro$value)==T] = 0					sl<- subpro[which(subpro$value>0),]					sr<-length(sl$value)					sa<-sum(subpro$value)					#populate array for step in loop					# first column is site					Rabund[rlab, 1]<-i					# Second column is treatment					Rabund[rlab, 2]<-j					#third column is size of sample					Rabund[rlab, 3]<-l					# fourth column is the mean value for the observations sampled					Rabund[rlab, 4]<-sr					Rabund[rlab, 8]<-sa						#create a limited specimen table of summary specimen results 						speci<-specimen[which(specimen$Site==i & specimen$treatment==j),]					#fifth column is native
bee abundance from the specimen data					Rabund[rlab,5]<-speci$specabund					#sixth column is native bee richness from spec data					Rabund[rlab,6]<-speci$specrich#
					Rabund[rlab, 7]<-m		}}		#Create table of correlations for each number of sections for each iteration		corlab<-corlab+1		abuncor[corlab,1]<-l*10		cor(Rabund[,4], Rabund[,5])->abuncor[corlab,2]		cor(Rabund[,4], Rabund[,6])->abuncor[corlab,3]		abuncor[corlab,4]<-mean(Rabund[,8])		}}abuncor<-rename(abuncor, c(V1="sections", V2="acor", V3="rcor", V4="specnum"))#
###CONSIDER USING QUANTILES RATHER THAN SE #Create summary table of abuncor with means and SEsstderror<-function(x){(sd(x)/sqrt(length(x)))*1.96}meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
#create panel for plots#par(mfrow=c(1,2))#This library should allow me to plot error barslibrary(Hmisc)#GENERATE PLOTS#quartz()#with(meanSEs, errbar(sections, acor.mean, acor.mean+acor.stderror, #acor.mean-acor.stderror,#	title(main=paste("observed and specimen abundance \n full dataset ", sep="\n")), #	xlab=paste("sampling effort \n (minutes)", sep="\n"),#	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),#	pch = 20, type = 'p'))#abline(h=0.964)#mtext(text=" 0.99", side = 4, line = 0, outer = FALSE, at = 0.99, las=2,#	col = 'red')quartz()with(meanSEs, errbar(specnum.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (number of specimens)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2
)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')meanSEs<-summaryBy(specnum+rcor~sections, data=abuncor, FUN=c(mean, stderror))#meanSEs$sections<-meanSEs$sections*2.5#
quartz()with(meanSEs, errbar(sections.mean, rcor.mean, rcor.mean+rcor.stderror, 	rcor.mean-rcor.stderror, 	title(main=paste("number of specimens and their richness \n for NJ 2011", 		sep="\n")), 	xlab=paste("sampling effort (minutes)", sep="\n"),	ylab=paste("correlation coefficient", sep="\n"), add=FALSE, ylim=c(0,1),	pch = 20, type = 'p', cex=2, lwd=4, cex.lab=2, cex.main=5, cex.axis=2, mar= c(5, 9, 4, 2) + 0.5))	box(lwd=2)#abline(h=0.80)#mtext(text=" 0.80", side = 4, line = 0, outer = FALSE, at = 0.838, las=2,#	col = 'red')detach(package:Hmisc)
gens <- 10output <- numeric(gens + 1)outputoutput[1] <- 25outputfor (t in 1:gens) output[t+1] <- output[t] + round(rnorm(n=1, mean = 0, sd = 2), 0)output
?aggregate
class(warpbreaks)
warpbreaks
gens <- 10output <- numeric(gens + 1)outputoutput[1] <- 25outputfor (t in 1:gens) output[t+1] <- output[t] + round(rnorm(n=1, mean = 0, sd = 2), 0)output
x=c(1,4,25,6,7,11,0,9,0,44,0,9)#
J<-(5:11)
x
J
J<-c(5,11)
x[J[1]<x<J[2]]
x[x<J[2]]
x[x<J[2]&&x>J[[1]]]
x[x<J[2]&x>J[[1]]]
raw
myls
#Midterm scripts
require(vegan)
varespec
# learn how to deal wtih dates and time in R, start visualizing phenology
load("/Users/mikeroswell/Downloads/gpaData.RDS")
load("/Rstudio_Git/RareBeePaper_2018/output/fits 1 .RData")
ls()
str(nulmods)
load("/Rstudio_Git/RareBeePaper_2018/output/fits5800.RData")
load("/Rstudio_Git/RareBeePaper_2018/output/fits5900.RData")
load("/Rstudio_Git/RareBeePaper_2018/output/fits7500.RData")
load("/Rstudio_Git/RareBeePaper_2018/output/fits8200.RData")
load("/Users/mikeroswell/Desktop/output/fits5750.RData")
load("/Users/mikeroswell/Desktop/output/fits5400.RData")
library(furrr)#
source("scripts/helper_funs/uniroot_gamma_and_lnorm.R")#
R_FUTURE_FORK_ENABLE=T#
library(iNEXT)#
# simulate full community#
fullcomm<-fit_SAD(rich=100, simpson=20)#
#
#get each sample size 5k times#
nc<-7#
plan(strategy = multiprocess, workers = nc)#
#
reps<-50#
SS<-200#
somedata_to_think_about<-future_map_dfr(1:reps, function(rep){#
    map_dfr(1:100, function(myrep){#
        data.frame(SS=SS, estimateD(sample_infinite(fullcomm[[3]], SS), base="coverage", level=.75))#
    })#
})
source("/Users/mikeroswell/Rstudio_Git/Dushoff_diversity/scripts/helper_funs/uniroot_gamma_and_lnorm.R")
getwd
getwd()
setwd()
setwd("/Rstudio_Git/Dushoff_diversity/scripts)
setwd("/Rstudio_Git/Dushoff_diversity/scripts")
)))
}}}}}}}}}
q
setwd("/Rstudio_Git/Dushoff_diversity/scripts")
library(furrr)#
source("scripts/helper_funs/uniroot_gamma_and_lnorm.R")#
R_FUTURE_FORK_ENABLE=T#
library(iNEXT)#
# simulate full community#
fullcomm<-fit_SAD(rich=100, simpson=20)#
#
#get each sample size 5k times#
nc<-7#
plan(strategy = multiprocess, workers = nc)#
#
reps<-50#
SS<-200#
somedata_to_think_about<-future_map_dfr(1:reps, function(rep){#
    map_dfr(1:100, function(myrep){#
        data.frame(SS=SS, estimateD(sample_infinite(fullcomm[[3]], SS), base="coverage", level=.75))#
    })#
})
setwd("/Rstudio_Git/Dushoff_diversity/")
library(furrr)#
source("scripts/helper_funs/uniroot_gamma_and_lnorm.R")#
R_FUTURE_FORK_ENABLE=T#
library(iNEXT)#
# simulate full community#
fullcomm<-fit_SAD(rich=100, simpson=20)#
#
#get each sample size 5k times#
nc<-7#
plan(strategy = multiprocess, workers = nc)#
#
reps<-50#
SS<-200#
somedata_to_think_about<-future_map_dfr(1:reps, function(rep){#
    map_dfr(1:100, function(myrep){#
        data.frame(SS=SS, estimateD(sample_infinite(fullcomm[[3]], SS), base="coverage", level=.75))#
    })#
})
head(somedata_to_think_about)
write.csv(somedata_to_think_about, "data/fromR/data_to_think_about.csv", row.names=F)
SS<-9000
SS<-900
somedata_to_think_about<-future_map_dfr(1:reps, function(rep){#
    map_dfr(1:100, function(myrep){#
        data.frame(SS=SS, estimateD(sample_infinite(fullcomm[[3]], SS), base="coverage", level=.75))#
    })#
})
write.csv(somedata_to_think_about, "data/fromR/data_to_think_about.csv", row.names=F)
somedata_to_think_about<-future_map_dfr(1:reps, function(rep){#
    map_dfr(1:100, function(myrep){#
        c1<-sample_infinite(fullcomm[[3]], SS)#
        c2<-sample_infinite(fullcomm2[[3]], SS)#
        asyc1<-Chao_Hill_abu(c1, c(0,1,2))#
        asyc2<-Chao_Hill_abu(c2, c(0,1,2))#
        data.frame(SS=SS, estimateD(rbind(c1,c2), base="coverage", level=.75)#
                   , c1Rich=asyc1[1],c2Rich=asyc2[1], c1Shan=asyc1[2], c2Shan=asyc2[2],c1Simp=asyc1[3], c2Simp=asyc2[3])#
    })#
})
fullcomm2<-fit_SAD(rich=20, simpson=10)
somedata_to_think_about<-future_map_dfr(1:reps, function(rep){#
    map_dfr(1:100, function(myrep){#
        c1<-sample_infinite(fullcomm[[3]], SS)#
        c2<-sample_infinite(fullcomm2[[3]], SS)#
        asyc1<-Chao_Hill_abu(c1, c(0,1,2))#
        asyc2<-Chao_Hill_abu(c2, c(0,1,2))#
        data.frame(SS=SS, estimateD(rbind(c1,c2), base="coverage", level=.75)#
                   , c1Rich=asyc1[1],c2Rich=asyc2[1], c1Shan=asyc1[2], c2Shan=asyc2[2],c1Simp=asyc1[3], c2Simp=asyc2[3])#
    })#
})
SS<-200
